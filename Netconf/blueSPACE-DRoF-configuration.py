# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_constellation_blueSPACE_DRoF_configuration__DRoF_configuration_constellation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-configuration - based on the path /DRoF-configuration/Constellation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__subcarrier_id','__bitsxsymbol','__powerxsymbol',)

  _yang_name = 'Constellation'
  _yang_namespace = 'urn:blueSPACE-DRoF-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subcarrier_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    self.__bitsxsymbol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bitsxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    self.__powerxsymbol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="powerxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-configuration', 'Constellation']

  def _get_subcarrier_id(self):
    """
    Getter method for subcarrier_id, mapped from YANG variable /DRoF_configuration/Constellation/subcarrier_id (string)
    """
    return self.__subcarrier_id
      
  def _set_subcarrier_id(self, v, load=False):
    """
    Setter method for subcarrier_id, mapped from YANG variable /DRoF_configuration/Constellation/subcarrier_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcarrier_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcarrier_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcarrier_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)""",
        })

    self.__subcarrier_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcarrier_id(self):
    self.__subcarrier_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)


  def _get_bitsxsymbol(self):
    """
    Getter method for bitsxsymbol, mapped from YANG variable /DRoF_configuration/Constellation/bitsxsymbol (string)
    """
    return self.__bitsxsymbol
      
  def _set_bitsxsymbol(self, v, load=False):
    """
    Setter method for bitsxsymbol, mapped from YANG variable /DRoF_configuration/Constellation/bitsxsymbol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bitsxsymbol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bitsxsymbol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bitsxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bitsxsymbol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bitsxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)""",
        })

    self.__bitsxsymbol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bitsxsymbol(self):
    self.__bitsxsymbol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bitsxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)


  def _get_powerxsymbol(self):
    """
    Getter method for powerxsymbol, mapped from YANG variable /DRoF_configuration/Constellation/powerxsymbol (string)
    """
    return self.__powerxsymbol
      
  def _set_powerxsymbol(self, v, load=False):
    """
    Setter method for powerxsymbol, mapped from YANG variable /DRoF_configuration/Constellation/powerxsymbol (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_powerxsymbol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_powerxsymbol() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="powerxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """powerxsymbol must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="powerxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)""",
        })

    self.__powerxsymbol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_powerxsymbol(self):
    self.__powerxsymbol = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="powerxsymbol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)

  subcarrier_id = __builtin__.property(_get_subcarrier_id, _set_subcarrier_id)
  bitsxsymbol = __builtin__.property(_get_bitsxsymbol, _set_bitsxsymbol)
  powerxsymbol = __builtin__.property(_get_powerxsymbol, _set_powerxsymbol)


  _pyangbind_elements = OrderedDict([('subcarrier_id', subcarrier_id), ('bitsxsymbol', bitsxsymbol), ('powerxsymbol', powerxsymbol), ])


class yc_monitor_blueSPACE_DRoF_configuration__DRoF_configuration_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-configuration - based on the path /DRoF-configuration/monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__subcarrier_id','__SNR',)

  _yang_name = 'monitor'
  _yang_namespace = 'urn:blueSPACE-DRoF-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subcarrier_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)
    self.__SNR = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="SNR", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-configuration', 'monitor']

  def _get_subcarrier_id(self):
    """
    Getter method for subcarrier_id, mapped from YANG variable /DRoF_configuration/monitor/subcarrier_id (string)
    """
    return self.__subcarrier_id
      
  def _set_subcarrier_id(self, v, load=False):
    """
    Setter method for subcarrier_id, mapped from YANG variable /DRoF_configuration/monitor/subcarrier_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcarrier_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcarrier_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcarrier_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)""",
        })

    self.__subcarrier_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcarrier_id(self):
    self.__subcarrier_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subcarrier-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)


  def _get_SNR(self):
    """
    Getter method for SNR, mapped from YANG variable /DRoF_configuration/monitor/SNR (string)
    """
    return self.__SNR
      
  def _set_SNR(self, v, load=False):
    """
    Setter method for SNR, mapped from YANG variable /DRoF_configuration/monitor/SNR (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_SNR is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_SNR() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="SNR", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """SNR must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="SNR", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)""",
        })

    self.__SNR = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_SNR(self):
    self.__SNR = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="SNR", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)

  subcarrier_id = __builtin__.property(_get_subcarrier_id)
  SNR = __builtin__.property(_get_SNR)


  _pyangbind_elements = OrderedDict([('subcarrier_id', subcarrier_id), ('SNR', SNR), ])


class yc_DRoF_configuration_blueSPACE_DRoF_configuration__DRoF_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-configuration - based on the path /DRoF-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__status','__nominal_central_frequency','__constellation','__FEC','__equalization','__monitor','__BER',)

  _yang_name = 'DRoF-configuration'
  _yang_namespace = 'urn:blueSPACE-DRoF-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__equalization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    self.__monitor = YANGDynClass(base=yc_monitor_blueSPACE_DRoF_configuration__DRoF_configuration_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'blueSPACE-DRoF-configuration:active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)
    self.__FEC = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)
    self.__constellation = YANGDynClass(base=yc_constellation_blueSPACE_DRoF_configuration__DRoF_configuration_constellation, is_container='container', yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)
    self.__BER = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="BER", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)
    self.__nominal_central_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-configuration']

  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /DRoF_configuration/status (identityref)
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /DRoF_configuration/status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'blueSPACE-DRoF-configuration:active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with identityref""",
          'defined-type': "blueSPACE-DRoF-configuration:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'blueSPACE-DRoF-configuration:active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'blueSPACE-DRoF-configuration:active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:standby': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'off': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'active': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)


  def _get_nominal_central_frequency(self):
    """
    Getter method for nominal_central_frequency, mapped from YANG variable /DRoF_configuration/nominal_central_frequency (string)
    """
    return self.__nominal_central_frequency
      
  def _set_nominal_central_frequency(self, v, load=False):
    """
    Setter method for nominal_central_frequency, mapped from YANG variable /DRoF_configuration/nominal_central_frequency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nominal_central_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nominal_central_frequency() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nominal_central_frequency must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)""",
        })

    self.__nominal_central_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nominal_central_frequency(self):
    self.__nominal_central_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)


  def _get_constellation(self):
    """
    Getter method for Constellation, mapped from YANG variable /DRoF_configuration/Constellation (container)
    """
    return self.__constellation
      
  def _set_constellation(self, v, load=False):
    """
    Setter method for Constellation, mapped from YANG variable /DRoF_configuration/Constellation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constellation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constellation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_constellation_blueSPACE_DRoF_configuration__DRoF_configuration_constellation, is_container='container', yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """Constellation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_constellation_blueSPACE_DRoF_configuration__DRoF_configuration_constellation, is_container='container', yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)""",
        })

    self.__constellation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_constellation(self):
    self.__constellation = YANGDynClass(base=yc_constellation_blueSPACE_DRoF_configuration__DRoF_configuration_constellation, is_container='container', yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)


  def _get_FEC(self):
    """
    Getter method for FEC, mapped from YANG variable /DRoF_configuration/FEC (identityref)
    """
    return self.__FEC
      
  def _set_FEC(self, v, load=False):
    """
    Setter method for FEC, mapped from YANG variable /DRoF_configuration/FEC (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_FEC is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_FEC() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """FEC must be of a type compatible with identityref""",
          'defined-type': "blueSPACE-DRoF-configuration:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)""",
        })

    self.__FEC = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_FEC(self):
    self.__FEC = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:SD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}, 'blueSPACE-DRoF-configuration:HD-FEC': {'@module': 'blueSPACE-DRoF-configuration', '@namespace': 'urn:blueSPACE-DRoF-configuration'}},), is_leaf=True, yang_name="FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='identityref', is_config=True)


  def _get_equalization(self):
    """
    Getter method for equalization, mapped from YANG variable /DRoF_configuration/equalization (string)
    """
    return self.__equalization
      
  def _set_equalization(self, v, load=False):
    """
    Setter method for equalization, mapped from YANG variable /DRoF_configuration/equalization (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equalization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equalization() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equalization must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)""",
        })

    self.__equalization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equalization(self):
    self.__equalization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=True)


  def _get_monitor(self):
    """
    Getter method for monitor, mapped from YANG variable /DRoF_configuration/monitor (container)
    """
    return self.__monitor
      
  def _set_monitor(self, v, load=False):
    """
    Setter method for monitor, mapped from YANG variable /DRoF_configuration/monitor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_monitor_blueSPACE_DRoF_configuration__DRoF_configuration_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_monitor_blueSPACE_DRoF_configuration__DRoF_configuration_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)""",
        })

    self.__monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor(self):
    self.__monitor = YANGDynClass(base=yc_monitor_blueSPACE_DRoF_configuration__DRoF_configuration_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)


  def _get_BER(self):
    """
    Getter method for BER, mapped from YANG variable /DRoF_configuration/BER (string)
    """
    return self.__BER
      
  def _set_BER(self, v, load=False):
    """
    Setter method for BER, mapped from YANG variable /DRoF_configuration/BER (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_BER is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_BER() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="BER", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """BER must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="BER", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)""",
        })

    self.__BER = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_BER(self):
    self.__BER = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="BER", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='string', is_config=False)

  status = __builtin__.property(_get_status, _set_status)
  nominal_central_frequency = __builtin__.property(_get_nominal_central_frequency, _set_nominal_central_frequency)
  constellation = __builtin__.property(_get_constellation, _set_constellation)
  FEC = __builtin__.property(_get_FEC, _set_FEC)
  equalization = __builtin__.property(_get_equalization, _set_equalization)
  monitor = __builtin__.property(_get_monitor, _set_monitor)
  BER = __builtin__.property(_get_BER)


  _pyangbind_elements = OrderedDict([('status', status), ('nominal_central_frequency', nominal_central_frequency), ('Constellation', constellation), ('FEC', FEC), ('equalization', equalization), ('monitor', monitor), ('BER', BER), ])


class blueSPACE_DRoF_configuration(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-configuration - based on the path /blueSPACE-DRoF-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Latest update to blueSPACE-DRoF-configuration YANG data model.
  """
  __slots__ = ('_path_helper', '_extmethods', '__DRoF_configuration',)

  _yang_name = 'blueSPACE-DRoF-configuration'
  _yang_namespace = 'urn:blueSPACE-DRoF-configuration'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__DRoF_configuration = YANGDynClass(base=yc_DRoF_configuration_blueSPACE_DRoF_configuration__DRoF_configuration, is_container='container', yang_name="DRoF-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_DRoF_configuration(self):
    """
    Getter method for DRoF_configuration, mapped from YANG variable /DRoF_configuration (container)
    """
    return self.__DRoF_configuration
      
  def _set_DRoF_configuration(self, v, load=False):
    """
    Setter method for DRoF_configuration, mapped from YANG variable /DRoF_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_DRoF_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_DRoF_configuration() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_DRoF_configuration_blueSPACE_DRoF_configuration__DRoF_configuration, is_container='container', yang_name="DRoF-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """DRoF_configuration must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_DRoF_configuration_blueSPACE_DRoF_configuration__DRoF_configuration, is_container='container', yang_name="DRoF-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)""",
        })

    self.__DRoF_configuration = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_DRoF_configuration(self):
    self.__DRoF_configuration = YANGDynClass(base=yc_DRoF_configuration_blueSPACE_DRoF_configuration__DRoF_configuration, is_container='container', yang_name="DRoF-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-configuration', defining_module='blueSPACE-DRoF-configuration', yang_type='container', is_config=True)

  DRoF_configuration = __builtin__.property(_get_DRoF_configuration, _set_DRoF_configuration)


  _pyangbind_elements = OrderedDict([('DRoF_configuration', DRoF_configuration), ])


