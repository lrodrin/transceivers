# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_supportable_capacity_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_capacity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability/supportable-capacity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_capacity','__min_capacity',)

  _yang_name = 'supportable-capacity'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_capacity = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)
    self.__min_capacity = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability', 'supportable-capacity']

  def _get_max_capacity(self):
    """
    Getter method for max_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity/max_capacity (uint32)

    YANG Description: e.g 50
    """
    return self.__max_capacity
      
  def _set_max_capacity(self, v, load=False):
    """
    Setter method for max_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity/max_capacity (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_capacity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_capacity() directly.

    YANG Description: e.g 50
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_capacity must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)""",
        })

    self.__max_capacity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_capacity(self):
    self.__max_capacity = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)


  def _get_min_capacity(self):
    """
    Getter method for min_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity/min_capacity (uint32)

    YANG Description: e.g 5
    """
    return self.__min_capacity
      
  def _set_min_capacity(self, v, load=False):
    """
    Setter method for min_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity/min_capacity (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_capacity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_capacity() directly.

    YANG Description: e.g 5
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_capacity must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)""",
        })

    self.__min_capacity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_capacity(self):
    self.__min_capacity = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="min-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)

  max_capacity = __builtin__.property(_get_max_capacity)
  min_capacity = __builtin__.property(_get_min_capacity)


  _pyangbind_elements = OrderedDict([('max_capacity', max_capacity), ('min_capacity', min_capacity), ])


class yc_supportable_constellation_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_constellation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability/supportable-Constellation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__constellation_id','__mod_type',)

  _yang_name = 'supportable-Constellation'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__constellation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="Constellation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__mod_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability', 'supportable-Constellation']

  def _get_constellation_id(self):
    """
    Getter method for constellation_id, mapped from YANG variable /DRoF_TP_capability/supportable_constellation/constellation_id (string)
    """
    return self.__constellation_id
      
  def _set_constellation_id(self, v, load=False):
    """
    Setter method for constellation_id, mapped from YANG variable /DRoF_TP_capability/supportable_constellation/constellation_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constellation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constellation_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="Constellation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """constellation_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="Constellation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__constellation_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_constellation_id(self):
    self.__constellation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="Constellation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_mod_type(self):
    """
    Getter method for mod_type, mapped from YANG variable /DRoF_TP_capability/supportable_constellation/mod_type (identityref)
    """
    return self.__mod_type
      
  def _set_mod_type(self, v, load=False):
    """
    Setter method for mod_type, mapped from YANG variable /DRoF_TP_capability/supportable_constellation/mod_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mod_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mod_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mod_type must be of a type compatible with identityref""",
          'defined-type': "blueSPACE-DRoF-TP-capability:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)""",
        })

    self.__mod_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mod_type(self):
    self.__mod_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam16': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam64': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam4': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:bpsk': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam8': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam32': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:qam256': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'qam128': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)

  constellation_id = __builtin__.property(_get_constellation_id)
  mod_type = __builtin__.property(_get_mod_type)


  _pyangbind_elements = OrderedDict([('constellation_id', constellation_id), ('mod_type', mod_type), ])


class yc_supportable_nominal_central_frequency_range_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_nominal_central_frequency_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability/supportable-nominal-central-frequency-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__adjustment_granularity','__grid_type','__lower_frequency','__upper_frequency',)

  _yang_name = 'supportable-nominal-central-frequency-range'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability', 'supportable-nominal-central-frequency-range']

  def _get_adjustment_granularity(self):
    """
    Getter method for adjustment_granularity, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/adjustment_granularity (string)

    YANG Description: e.g 6.25GHz
    """
    return self.__adjustment_granularity
      
  def _set_adjustment_granularity(self, v, load=False):
    """
    Setter method for adjustment_granularity, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/adjustment_granularity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adjustment_granularity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adjustment_granularity() directly.

    YANG Description: e.g 6.25GHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adjustment_granularity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__adjustment_granularity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adjustment_granularity(self):
    self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_grid_type(self):
    """
    Getter method for grid_type, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/grid_type (string)

    YANG Description: e.g Flex
    """
    return self.__grid_type
      
  def _set_grid_type(self, v, load=False):
    """
    Setter method for grid_type, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/grid_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grid_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grid_type() directly.

    YANG Description: e.g Flex
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grid_type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__grid_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grid_type(self):
    self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_lower_frequency(self):
    """
    Getter method for lower_frequency, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/lower_frequency (string)

    YANG Description: e.g 191.494THz
    """
    return self.__lower_frequency
      
  def _set_lower_frequency(self, v, load=False):
    """
    Setter method for lower_frequency, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/lower_frequency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lower_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lower_frequency() directly.

    YANG Description: e.g 191.494THz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lower_frequency must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__lower_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lower_frequency(self):
    self.__lower_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lower-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_upper_frequency(self):
    """
    Getter method for upper_frequency, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/upper_frequency (string)

    YANG Description: e.g 195,256THz
    """
    return self.__upper_frequency
      
  def _set_upper_frequency(self, v, load=False):
    """
    Setter method for upper_frequency, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range/upper_frequency (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_upper_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_upper_frequency() directly.

    YANG Description: e.g 195,256THz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """upper_frequency must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__upper_frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_upper_frequency(self):
    self.__upper_frequency = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="upper-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)

  adjustment_granularity = __builtin__.property(_get_adjustment_granularity)
  grid_type = __builtin__.property(_get_grid_type)
  lower_frequency = __builtin__.property(_get_lower_frequency)
  upper_frequency = __builtin__.property(_get_upper_frequency)


  _pyangbind_elements = OrderedDict([('adjustment_granularity', adjustment_granularity), ('grid_type', grid_type), ('lower_frequency', lower_frequency), ('upper_frequency', upper_frequency), ])


class yc_supportable_FEC_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_FEC(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability/supportable-FEC. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__fec_id','__fec_type',)

  _yang_name = 'supportable-FEC'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fec-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__fec_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="fec-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability', 'supportable-FEC']

  def _get_fec_id(self):
    """
    Getter method for fec_id, mapped from YANG variable /DRoF_TP_capability/supportable_FEC/fec_id (string)
    """
    return self.__fec_id
      
  def _set_fec_id(self, v, load=False):
    """
    Setter method for fec_id, mapped from YANG variable /DRoF_TP_capability/supportable_FEC/fec_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="fec-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fec-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__fec_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_id(self):
    self.__fec_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fec-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_fec_type(self):
    """
    Getter method for fec_type, mapped from YANG variable /DRoF_TP_capability/supportable_FEC/fec_type (identityref)
    """
    return self.__fec_type
      
  def _set_fec_type(self, v, load=False):
    """
    Setter method for fec_type, mapped from YANG variable /DRoF_TP_capability/supportable_FEC/fec_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="fec-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_type must be of a type compatible with identityref""",
          'defined-type': "blueSPACE-DRoF-TP-capability:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="fec-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)""",
        })

    self.__fec_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_type(self):
    self.__fec_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'SD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:HD-FEC': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="fec-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)

  fec_id = __builtin__.property(_get_fec_id)
  fec_type = __builtin__.property(_get_fec_type)


  _pyangbind_elements = OrderedDict([('fec_id', fec_id), ('fec_type', fec_type), ])


class yc_supportable_equalization_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_equalization(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability/supportable-equalization. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__equalization_id','__equalization_type',)

  _yang_name = 'supportable-equalization'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__equalization_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="equalization-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)
    self.__equalization_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability', 'supportable-equalization']

  def _get_equalization_id(self):
    """
    Getter method for equalization_id, mapped from YANG variable /DRoF_TP_capability/supportable_equalization/equalization_id (string)
    """
    return self.__equalization_id
      
  def _set_equalization_id(self, v, load=False):
    """
    Setter method for equalization_id, mapped from YANG variable /DRoF_TP_capability/supportable_equalization/equalization_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equalization_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equalization_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="equalization-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equalization_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__equalization_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equalization_id(self):
    self.__equalization_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalization-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_equalization_type(self):
    """
    Getter method for equalization_type, mapped from YANG variable /DRoF_TP_capability/supportable_equalization/equalization_type (identityref)
    """
    return self.__equalization_type
      
  def _set_equalization_type(self, v, load=False):
    """
    Setter method for equalization_type, mapped from YANG variable /DRoF_TP_capability/supportable_equalization/equalization_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equalization_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equalization_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="equalization-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equalization_type must be of a type compatible with identityref""",
          'defined-type': "blueSPACE-DRoF-TP-capability:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="equalization-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)""",
        })

    self.__equalization_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equalization_type(self):
    self.__equalization_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:MMSE': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}, 'blueSPACE-DRoF-TP-capability:ZF': {'@module': 'blueSPACE-DRoF-TP-capability', '@namespace': 'urn:blueSPACE-DRoF-TP-capability'}},), is_leaf=True, yang_name="equalization-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='identityref', is_config=False)

  equalization_id = __builtin__.property(_get_equalization_id)
  equalization_type = __builtin__.property(_get_equalization_type)


  _pyangbind_elements = OrderedDict([('equalization_id', equalization_id), ('equalization_type', equalization_type), ])


class yc_DRoF_TP_capability_blueSPACE_DRoF_TP_capability__DRoF_TP_capability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /DRoF-TP-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__supportable_capacity','__supportable_modulation','__supportable_subcarriers','__supportable_constellation','__supportable_nominal_central_frequency_range','__supportable_bandwidth','__supportable_FEC','__supportable_equalization',)

  _yang_name = 'DRoF-TP-capability'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supportable_capacity = YANGDynClass(base=yc_supportable_capacity_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_capacity, is_container='container', yang_name="supportable-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    self.__supportable_subcarriers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="supportable-subcarriers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)
    self.__supportable_constellation = YANGDynClass(base=yc_supportable_constellation_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_constellation, is_container='container', yang_name="supportable-Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    self.__supportable_FEC = YANGDynClass(base=yc_supportable_FEC_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_FEC, is_container='container', yang_name="supportable-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    self.__supportable_bandwidth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__supportable_equalization = YANGDynClass(base=yc_supportable_equalization_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_equalization, is_container='container', yang_name="supportable-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    self.__supportable_modulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-modulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    self.__supportable_nominal_central_frequency_range = YANGDynClass(base=yc_supportable_nominal_central_frequency_range_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_nominal_central_frequency_range, is_container='container', yang_name="supportable-nominal-central-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['DRoF-TP-capability']

  def _get_supportable_capacity(self):
    """
    Getter method for supportable_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity (container)
    """
    return self.__supportable_capacity
      
  def _set_supportable_capacity(self, v, load=False):
    """
    Setter method for supportable_capacity, mapped from YANG variable /DRoF_TP_capability/supportable_capacity (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_capacity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_capacity() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supportable_capacity_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_capacity, is_container='container', yang_name="supportable-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_capacity must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supportable_capacity_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_capacity, is_container='container', yang_name="supportable-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)""",
        })

    self.__supportable_capacity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_capacity(self):
    self.__supportable_capacity = YANGDynClass(base=yc_supportable_capacity_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_capacity, is_container='container', yang_name="supportable-capacity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)


  def _get_supportable_modulation(self):
    """
    Getter method for supportable_modulation, mapped from YANG variable /DRoF_TP_capability/supportable_modulation (string)

    YANG Description: e.g. OFDM
    """
    return self.__supportable_modulation
      
  def _set_supportable_modulation(self, v, load=False):
    """
    Setter method for supportable_modulation, mapped from YANG variable /DRoF_TP_capability/supportable_modulation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_modulation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_modulation() directly.

    YANG Description: e.g. OFDM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="supportable-modulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_modulation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-modulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__supportable_modulation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_modulation(self):
    self.__supportable_modulation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-modulation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_supportable_subcarriers(self):
    """
    Getter method for supportable_subcarriers, mapped from YANG variable /DRoF_TP_capability/supportable_subcarriers (uint32)
    """
    return self.__supportable_subcarriers
      
  def _set_supportable_subcarriers(self, v, load=False):
    """
    Setter method for supportable_subcarriers, mapped from YANG variable /DRoF_TP_capability/supportable_subcarriers (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_subcarriers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_subcarriers() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="supportable-subcarriers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_subcarriers must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="supportable-subcarriers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)""",
        })

    self.__supportable_subcarriers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_subcarriers(self):
    self.__supportable_subcarriers = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="supportable-subcarriers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='uint32', is_config=False)


  def _get_supportable_constellation(self):
    """
    Getter method for supportable_constellation, mapped from YANG variable /DRoF_TP_capability/supportable_constellation (container)
    """
    return self.__supportable_constellation
      
  def _set_supportable_constellation(self, v, load=False):
    """
    Setter method for supportable_constellation, mapped from YANG variable /DRoF_TP_capability/supportable_constellation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_constellation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_constellation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supportable_constellation_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_constellation, is_container='container', yang_name="supportable-Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_constellation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supportable_constellation_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_constellation, is_container='container', yang_name="supportable-Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)""",
        })

    self.__supportable_constellation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_constellation(self):
    self.__supportable_constellation = YANGDynClass(base=yc_supportable_constellation_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_constellation, is_container='container', yang_name="supportable-Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)


  def _get_supportable_nominal_central_frequency_range(self):
    """
    Getter method for supportable_nominal_central_frequency_range, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range (container)
    """
    return self.__supportable_nominal_central_frequency_range
      
  def _set_supportable_nominal_central_frequency_range(self, v, load=False):
    """
    Setter method for supportable_nominal_central_frequency_range, mapped from YANG variable /DRoF_TP_capability/supportable_nominal_central_frequency_range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_nominal_central_frequency_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_nominal_central_frequency_range() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supportable_nominal_central_frequency_range_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_nominal_central_frequency_range, is_container='container', yang_name="supportable-nominal-central-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_nominal_central_frequency_range must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supportable_nominal_central_frequency_range_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_nominal_central_frequency_range, is_container='container', yang_name="supportable-nominal-central-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)""",
        })

    self.__supportable_nominal_central_frequency_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_nominal_central_frequency_range(self):
    self.__supportable_nominal_central_frequency_range = YANGDynClass(base=yc_supportable_nominal_central_frequency_range_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_nominal_central_frequency_range, is_container='container', yang_name="supportable-nominal-central-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)


  def _get_supportable_bandwidth(self):
    """
    Getter method for supportable_bandwidth, mapped from YANG variable /DRoF_TP_capability/supportable_bandwidth (string)

    YANG Description: e.g. 25GHz
    """
    return self.__supportable_bandwidth
      
  def _set_supportable_bandwidth(self, v, load=False):
    """
    Setter method for supportable_bandwidth, mapped from YANG variable /DRoF_TP_capability/supportable_bandwidth (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_bandwidth() directly.

    YANG Description: e.g. 25GHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="supportable-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_bandwidth must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)""",
        })

    self.__supportable_bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_bandwidth(self):
    self.__supportable_bandwidth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supportable-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='string', is_config=False)


  def _get_supportable_FEC(self):
    """
    Getter method for supportable_FEC, mapped from YANG variable /DRoF_TP_capability/supportable_FEC (container)
    """
    return self.__supportable_FEC
      
  def _set_supportable_FEC(self, v, load=False):
    """
    Setter method for supportable_FEC, mapped from YANG variable /DRoF_TP_capability/supportable_FEC (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_FEC is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_FEC() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supportable_FEC_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_FEC, is_container='container', yang_name="supportable-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_FEC must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supportable_FEC_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_FEC, is_container='container', yang_name="supportable-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)""",
        })

    self.__supportable_FEC = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_FEC(self):
    self.__supportable_FEC = YANGDynClass(base=yc_supportable_FEC_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_FEC, is_container='container', yang_name="supportable-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)


  def _get_supportable_equalization(self):
    """
    Getter method for supportable_equalization, mapped from YANG variable /DRoF_TP_capability/supportable_equalization (container)
    """
    return self.__supportable_equalization
      
  def _set_supportable_equalization(self, v, load=False):
    """
    Setter method for supportable_equalization, mapped from YANG variable /DRoF_TP_capability/supportable_equalization (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supportable_equalization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supportable_equalization() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_supportable_equalization_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_equalization, is_container='container', yang_name="supportable-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supportable_equalization must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_supportable_equalization_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_equalization, is_container='container', yang_name="supportable-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)""",
        })

    self.__supportable_equalization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supportable_equalization(self):
    self.__supportable_equalization = YANGDynClass(base=yc_supportable_equalization_blueSPACE_DRoF_TP_capability__DRoF_TP_capability_supportable_equalization, is_container='container', yang_name="supportable-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=False)

  supportable_capacity = __builtin__.property(_get_supportable_capacity)
  supportable_modulation = __builtin__.property(_get_supportable_modulation)
  supportable_subcarriers = __builtin__.property(_get_supportable_subcarriers)
  supportable_constellation = __builtin__.property(_get_supportable_constellation)
  supportable_nominal_central_frequency_range = __builtin__.property(_get_supportable_nominal_central_frequency_range)
  supportable_bandwidth = __builtin__.property(_get_supportable_bandwidth)
  supportable_FEC = __builtin__.property(_get_supportable_FEC)
  supportable_equalization = __builtin__.property(_get_supportable_equalization)


  _pyangbind_elements = OrderedDict([('supportable_capacity', supportable_capacity), ('supportable_modulation', supportable_modulation), ('supportable_subcarriers', supportable_subcarriers), ('supportable_constellation', supportable_constellation), ('supportable_nominal_central_frequency_range', supportable_nominal_central_frequency_range), ('supportable_bandwidth', supportable_bandwidth), ('supportable_FEC', supportable_FEC), ('supportable_equalization', supportable_equalization), ])


class blueSPACE_DRoF_TP_capability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module blueSPACE-DRoF-TP-capability - based on the path /blueSPACE-DRoF-TP-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Latest update to blueSPACE-DRoF-TP-capability YANG data model.
  """
  __slots__ = ('_path_helper', '_extmethods', '__DRoF_TP_capability',)

  _yang_name = 'blueSPACE-DRoF-TP-capability'
  _yang_namespace = 'urn:blueSPACE-DRoF-TP-capability'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__DRoF_TP_capability = YANGDynClass(base=yc_DRoF_TP_capability_blueSPACE_DRoF_TP_capability__DRoF_TP_capability, is_container='container', yang_name="DRoF-TP-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_DRoF_TP_capability(self):
    """
    Getter method for DRoF_TP_capability, mapped from YANG variable /DRoF_TP_capability (container)
    """
    return self.__DRoF_TP_capability
      
  def _set_DRoF_TP_capability(self, v, load=False):
    """
    Setter method for DRoF_TP_capability, mapped from YANG variable /DRoF_TP_capability (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_DRoF_TP_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_DRoF_TP_capability() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_DRoF_TP_capability_blueSPACE_DRoF_TP_capability__DRoF_TP_capability, is_container='container', yang_name="DRoF-TP-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """DRoF_TP_capability must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_DRoF_TP_capability_blueSPACE_DRoF_TP_capability__DRoF_TP_capability, is_container='container', yang_name="DRoF-TP-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=True)""",
        })

    self.__DRoF_TP_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_DRoF_TP_capability(self):
    self.__DRoF_TP_capability = YANGDynClass(base=yc_DRoF_TP_capability_blueSPACE_DRoF_TP_capability__DRoF_TP_capability, is_container='container', yang_name="DRoF-TP-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:blueSPACE-DRoF-TP-capability', defining_module='blueSPACE-DRoF-TP-capability', yang_type='container', is_config=True)

  DRoF_TP_capability = __builtin__.property(_get_DRoF_TP_capability, _set_DRoF_TP_capability)


  _pyangbind_elements = OrderedDict([('DRoF_TP_capability', DRoF_TP_capability), ])


