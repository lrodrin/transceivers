# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_frequency_slot_sliceable_transceiver_sdm__transceiver_slice_optical_channel_frequency_slot(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice/optical-channel/frequency-slot. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ncf','__slot_width',)

  _yang_name = 'frequency-slot'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slot_width = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="slot-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)
    self.__ncf = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ncf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='int32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice', u'optical-channel', u'frequency-slot']

  def _get_ncf(self):
    """
    Getter method for ncf, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot/ncf (int32)

    YANG Description: Nominal central frequency = 193.1 THz + n x 0.00625 THz. 
where 193.1 THz is ITU-T anchor frequency for transmission 
over the C band, and n is a positive or negative integer including 0.
    """
    return self.__ncf
      
  def _set_ncf(self, v, load=False):
    """
    Setter method for ncf, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot/ncf (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ncf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ncf() directly.

    YANG Description: Nominal central frequency = 193.1 THz + n x 0.00625 THz. 
where 193.1 THz is ITU-T anchor frequency for transmission 
over the C band, and n is a positive or negative integer including 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ncf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ncf must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ncf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='int32', is_config=True)""",
        })

    self.__ncf = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ncf(self):
    self.__ncf = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="ncf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='int32', is_config=True)


  def _get_slot_width(self):
    """
    Getter method for slot_width, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot/slot_width (uint32)

    YANG Description: Slot width = m x 12.5 GHz, where m is an integer greater than or equal to 1.
    """
    return self.__slot_width
      
  def _set_slot_width(self, v, load=False):
    """
    Setter method for slot_width, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot/slot_width (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_width() directly.

    YANG Description: Slot width = m x 12.5 GHz, where m is an integer greater than or equal to 1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="slot-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_width must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="slot-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)""",
        })

    self.__slot_width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_width(self):
    self.__slot_width = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="slot-width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)

  ncf = __builtin__.property(_get_ncf, _set_ncf)
  slot_width = __builtin__.property(_get_slot_width, _set_slot_width)


  _pyangbind_elements = OrderedDict([('ncf', ncf), ('slot_width', slot_width), ])


class yc_optical_channel_sliceable_transceiver_sdm__transceiver_slice_optical_channel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice/optical-channel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opticalchannelid','__coreid','__modeid','__frequency_slot',)

  _yang_name = 'optical-channel'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__coreid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="coreid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__frequency_slot = YANGDynClass(base=yc_frequency_slot_sliceable_transceiver_sdm__transceiver_slice_optical_channel_frequency_slot, is_container='container', yang_name="frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    self.__modeid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modeid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__opticalchannelid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice', u'optical-channel']

  def _get_opticalchannelid(self):
    """
    Getter method for opticalchannelid, mapped from YANG variable /transceiver/slice/optical_channel/opticalchannelid (string)
    """
    return self.__opticalchannelid
      
  def _set_opticalchannelid(self, v, load=False):
    """
    Setter method for opticalchannelid, mapped from YANG variable /transceiver/slice/optical_channel/opticalchannelid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opticalchannelid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opticalchannelid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opticalchannelid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__opticalchannelid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opticalchannelid(self):
    self.__opticalchannelid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_coreid(self):
    """
    Getter method for coreid, mapped from YANG variable /transceiver/slice/optical_channel/coreid (string)
    """
    return self.__coreid
      
  def _set_coreid(self, v, load=False):
    """
    Setter method for coreid, mapped from YANG variable /transceiver/slice/optical_channel/coreid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_coreid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_coreid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="coreid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """coreid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="coreid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__coreid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_coreid(self):
    self.__coreid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="coreid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_modeid(self):
    """
    Getter method for modeid, mapped from YANG variable /transceiver/slice/optical_channel/modeid (string)

    YANG Description: e.g. lp01
    """
    return self.__modeid
      
  def _set_modeid(self, v, load=False):
    """
    Setter method for modeid, mapped from YANG variable /transceiver/slice/optical_channel/modeid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modeid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modeid() directly.

    YANG Description: e.g. lp01
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="modeid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modeid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modeid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__modeid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modeid(self):
    self.__modeid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modeid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_frequency_slot(self):
    """
    Getter method for frequency_slot, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot (container)
    """
    return self.__frequency_slot
      
  def _set_frequency_slot(self, v, load=False):
    """
    Setter method for frequency_slot, mapped from YANG variable /transceiver/slice/optical_channel/frequency_slot (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency_slot is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency_slot() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_frequency_slot_sliceable_transceiver_sdm__transceiver_slice_optical_channel_frequency_slot, is_container='container', yang_name="frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency_slot must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_frequency_slot_sliceable_transceiver_sdm__transceiver_slice_optical_channel_frequency_slot, is_container='container', yang_name="frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)""",
        })

    self.__frequency_slot = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency_slot(self):
    self.__frequency_slot = YANGDynClass(base=yc_frequency_slot_sliceable_transceiver_sdm__transceiver_slice_optical_channel_frequency_slot, is_container='container', yang_name="frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)

  opticalchannelid = __builtin__.property(_get_opticalchannelid, _set_opticalchannelid)
  coreid = __builtin__.property(_get_coreid, _set_coreid)
  modeid = __builtin__.property(_get_modeid, _set_modeid)
  frequency_slot = __builtin__.property(_get_frequency_slot, _set_frequency_slot)


  _pyangbind_elements = OrderedDict([('opticalchannelid', opticalchannelid), ('coreid', coreid), ('modeid', modeid), ('frequency_slot', frequency_slot), ])


class yc_equalization_sliceable_transceiver_sdm__transceiver_slice_optical_signal_equalization(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice/optical-signal/equalization. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__equalizationid','__mimo','__num_taps',)

  _yang_name = 'equalization'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__equalizationid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalizationid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__mimo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mimo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__num_taps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num_taps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice', u'optical-signal', u'equalization']

  def _get_equalizationid(self):
    """
    Getter method for equalizationid, mapped from YANG variable /transceiver/slice/optical_signal/equalization/equalizationid (string)
    """
    return self.__equalizationid
      
  def _set_equalizationid(self, v, load=False):
    """
    Setter method for equalizationid, mapped from YANG variable /transceiver/slice/optical_signal/equalization/equalizationid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equalizationid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equalizationid() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="equalizationid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equalizationid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalizationid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__equalizationid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equalizationid(self):
    self.__equalizationid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="equalizationid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_mimo(self):
    """
    Getter method for mimo, mapped from YANG variable /transceiver/slice/optical_signal/equalization/mimo (string)
    """
    return self.__mimo
      
  def _set_mimo(self, v, load=False):
    """
    Setter method for mimo, mapped from YANG variable /transceiver/slice/optical_signal/equalization/mimo (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mimo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mimo() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mimo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mimo must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mimo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__mimo = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mimo(self):
    self.__mimo = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mimo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_num_taps(self):
    """
    Getter method for num_taps, mapped from YANG variable /transceiver/slice/optical_signal/equalization/num_taps (uint32)
    """
    return self.__num_taps
      
  def _set_num_taps(self, v, load=False):
    """
    Setter method for num_taps, mapped from YANG variable /transceiver/slice/optical_signal/equalization/num_taps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_taps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_taps() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num_taps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """num_taps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num_taps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)""",
        })

    self.__num_taps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_num_taps(self):
    self.__num_taps = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="num_taps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='uint32', is_config=True)

  equalizationid = __builtin__.property(_get_equalizationid, _set_equalizationid)
  mimo = __builtin__.property(_get_mimo, _set_mimo)
  num_taps = __builtin__.property(_get_num_taps, _set_num_taps)


  _pyangbind_elements = OrderedDict([('equalizationid', equalizationid), ('mimo', mimo), ('num_taps', num_taps), ])


class yc_monitor_sliceable_transceiver_sdm__transceiver_slice_optical_signal_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice/optical-signal/monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ber','__osnr',)

  _yang_name = 'monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__osnr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice', u'optical-signal', u'monitor']

  def _get_ber(self):
    """
    Getter method for ber, mapped from YANG variable /transceiver/slice/optical_signal/monitor/ber (string)
    """
    return self.__ber
      
  def _set_ber(self, v, load=False):
    """
    Setter method for ber, mapped from YANG variable /transceiver/slice/optical_signal/monitor/ber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ber() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ber(self):
    self.__ber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_osnr(self):
    """
    Getter method for osnr, mapped from YANG variable /transceiver/slice/optical_signal/monitor/osnr (string)
    """
    return self.__osnr
      
  def _set_osnr(self, v, load=False):
    """
    Setter method for osnr, mapped from YANG variable /transceiver/slice/optical_signal/monitor/osnr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_osnr() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """osnr must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_osnr(self):
    self.__osnr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)

  ber = __builtin__.property(_get_ber, _set_ber)
  osnr = __builtin__.property(_get_osnr, _set_osnr)


  _pyangbind_elements = OrderedDict([('ber', ber), ('osnr', osnr), ])


class yc_optical_signal_sliceable_transceiver_sdm__transceiver_slice_optical_signal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice/optical-signal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__opticalchannelid','__constellation','__bandwidth','__fec','__equalization','__monitor',)

  _yang_name = 'optical-signal'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__fec = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="fec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)
    self.__equalization = YANGDynClass(base=yc_equalization_sliceable_transceiver_sdm__transceiver_slice_optical_signal_equalization, is_container='container', yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='decimal64', is_config=True)
    self.__opticalchannelid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='leafref', is_config=True)
    self.__constellation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)
    self.__monitor = YANGDynClass(base=yc_monitor_sliceable_transceiver_sdm__transceiver_slice_optical_signal_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice', u'optical-signal']

  def _get_opticalchannelid(self):
    """
    Getter method for opticalchannelid, mapped from YANG variable /transceiver/slice/optical_signal/opticalchannelid (leafref)
    """
    return self.__opticalchannelid
      
  def _set_opticalchannelid(self, v, load=False):
    """
    Setter method for opticalchannelid, mapped from YANG variable /transceiver/slice/optical_signal/opticalchannelid (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_opticalchannelid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_opticalchannelid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """opticalchannelid must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='leafref', is_config=True)""",
        })

    self.__opticalchannelid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_opticalchannelid(self):
    self.__opticalchannelid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="opticalchannelid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='leafref', is_config=True)


  def _get_constellation(self):
    """
    Getter method for Constellation, mapped from YANG variable /transceiver/slice/optical_signal/Constellation (identityref)
    """
    return self.__constellation
      
  def _set_constellation(self, v, load=False):
    """
    Setter method for Constellation, mapped from YANG variable /transceiver/slice/optical_signal/Constellation (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constellation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constellation() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """Constellation must be of a type compatible with identityref""",
          'defined-type': "sliceable-transceiver-sdm:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)""",
        })

    self.__constellation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_constellation(self):
    self.__constellation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qpsk': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam4': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam64': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:qam16': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="Constellation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /transceiver/slice/optical_signal/bandwidth (decimal64)
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /transceiver/slice/optical_signal/bandwidth (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='decimal64', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='decimal64', is_config=True)


  def _get_fec(self):
    """
    Getter method for fec, mapped from YANG variable /transceiver/slice/optical_signal/fec (identityref)
    """
    return self.__fec
      
  def _set_fec(self, v, load=False):
    """
    Setter method for fec, mapped from YANG variable /transceiver/slice/optical_signal/fec (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="fec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec must be of a type compatible with identityref""",
          'defined-type': "sliceable-transceiver-sdm:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="fec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)""",
        })

    self.__fec = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec(self):
    self.__fec = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={u'sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:sd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}, u'sliceable-transceiver-sdm:hd-fec': {u'@namespace': u'urn:sliceable-transceiver-sdm', u'@module': u'sliceable-transceiver-sdm'}},), is_leaf=True, yang_name="fec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='identityref', is_config=True)


  def _get_equalization(self):
    """
    Getter method for equalization, mapped from YANG variable /transceiver/slice/optical_signal/equalization (container)
    """
    return self.__equalization
      
  def _set_equalization(self, v, load=False):
    """
    Setter method for equalization, mapped from YANG variable /transceiver/slice/optical_signal/equalization (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_equalization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_equalization() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_equalization_sliceable_transceiver_sdm__transceiver_slice_optical_signal_equalization, is_container='container', yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """equalization must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_equalization_sliceable_transceiver_sdm__transceiver_slice_optical_signal_equalization, is_container='container', yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)""",
        })

    self.__equalization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_equalization(self):
    self.__equalization = YANGDynClass(base=yc_equalization_sliceable_transceiver_sdm__transceiver_slice_optical_signal_equalization, is_container='container', yang_name="equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)


  def _get_monitor(self):
    """
    Getter method for monitor, mapped from YANG variable /transceiver/slice/optical_signal/monitor (container)
    """
    return self.__monitor
      
  def _set_monitor(self, v, load=False):
    """
    Setter method for monitor, mapped from YANG variable /transceiver/slice/optical_signal/monitor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitor() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_monitor_sliceable_transceiver_sdm__transceiver_slice_optical_signal_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """monitor must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_monitor_sliceable_transceiver_sdm__transceiver_slice_optical_signal_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)""",
        })

    self.__monitor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_monitor(self):
    self.__monitor = YANGDynClass(base=yc_monitor_sliceable_transceiver_sdm__transceiver_slice_optical_signal_monitor, is_container='container', yang_name="monitor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)

  opticalchannelid = __builtin__.property(_get_opticalchannelid, _set_opticalchannelid)
  constellation = __builtin__.property(_get_constellation, _set_constellation)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  fec = __builtin__.property(_get_fec, _set_fec)
  equalization = __builtin__.property(_get_equalization, _set_equalization)
  monitor = __builtin__.property(_get_monitor, _set_monitor)


  _pyangbind_elements = OrderedDict([('opticalchannelid', opticalchannelid), ('Constellation', constellation), ('bandwidth', bandwidth), ('fec', fec), ('equalization', equalization), ('monitor', monitor), ])


class yc_slice_sliceable_transceiver_sdm__transceiver_slice(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver/slice. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__sliceid','__optical_channel','__optical_signal',)

  _yang_name = 'slice'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_signal = YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_signal_sliceable_transceiver_sdm__transceiver_slice_optical_signal, yang_name="optical-signal", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)
    self.__sliceid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sliceid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    self.__optical_channel = YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_channel_sliceable_transceiver_sdm__transceiver_slice_optical_channel, yang_name="optical-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver', u'slice']

  def _get_sliceid(self):
    """
    Getter method for sliceid, mapped from YANG variable /transceiver/slice/sliceid (string)
    """
    return self.__sliceid
      
  def _set_sliceid(self, v, load=False):
    """
    Setter method for sliceid, mapped from YANG variable /transceiver/slice/sliceid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sliceid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sliceid() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sliceid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sliceid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sliceid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)""",
        })

    self.__sliceid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sliceid(self):
    self.__sliceid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sliceid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='string', is_config=True)


  def _get_optical_channel(self):
    """
    Getter method for optical_channel, mapped from YANG variable /transceiver/slice/optical_channel (list)
    """
    return self.__optical_channel
      
  def _set_optical_channel(self, v, load=False):
    """
    Setter method for optical_channel, mapped from YANG variable /transceiver/slice/optical_channel (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_channel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_channel() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opticalchannelid",yc_optical_channel_sliceable_transceiver_sdm__transceiver_slice_optical_channel, yang_name="optical-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_channel must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_channel_sliceable_transceiver_sdm__transceiver_slice_optical_channel, yang_name="optical-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)""",
        })

    self.__optical_channel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_channel(self):
    self.__optical_channel = YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_channel_sliceable_transceiver_sdm__transceiver_slice_optical_channel, yang_name="optical-channel", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-channel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)


  def _get_optical_signal(self):
    """
    Getter method for optical_signal, mapped from YANG variable /transceiver/slice/optical_signal (list)
    """
    return self.__optical_signal
      
  def _set_optical_signal(self, v, load=False):
    """
    Setter method for optical_signal, mapped from YANG variable /transceiver/slice/optical_signal (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_signal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_signal() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("opticalchannelid",yc_optical_signal_sliceable_transceiver_sdm__transceiver_slice_optical_signal, yang_name="optical-signal", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_signal must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_signal_sliceable_transceiver_sdm__transceiver_slice_optical_signal, yang_name="optical-signal", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)""",
        })

    self.__optical_signal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_signal(self):
    self.__optical_signal = YANGDynClass(base=YANGListType("opticalchannelid",yc_optical_signal_sliceable_transceiver_sdm__transceiver_slice_optical_signal, yang_name="optical-signal", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='opticalchannelid', extensions=None), is_container='list', yang_name="optical-signal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)

  sliceid = __builtin__.property(_get_sliceid, _set_sliceid)
  optical_channel = __builtin__.property(_get_optical_channel, _set_optical_channel)
  optical_signal = __builtin__.property(_get_optical_signal, _set_optical_signal)


  _pyangbind_elements = OrderedDict([('sliceid', sliceid), ('optical_channel', optical_channel), ('optical_signal', optical_signal), ])


class yc_transceiver_sliceable_transceiver_sdm__transceiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /transceiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__slice',)

  _yang_name = 'transceiver'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slice = YANGDynClass(base=YANGListType("sliceid",yc_slice_sliceable_transceiver_sdm__transceiver_slice, yang_name="slice", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sliceid', extensions=None), is_container='list', yang_name="slice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return [u'transceiver']

  def _get_slice(self):
    """
    Getter method for slice, mapped from YANG variable /transceiver/slice (list)
    """
    return self.__slice
      
  def _set_slice(self, v, load=False):
    """
    Setter method for slice, mapped from YANG variable /transceiver/slice (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slice is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slice() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("sliceid",yc_slice_sliceable_transceiver_sdm__transceiver_slice, yang_name="slice", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sliceid', extensions=None), is_container='list', yang_name="slice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slice must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("sliceid",yc_slice_sliceable_transceiver_sdm__transceiver_slice, yang_name="slice", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sliceid', extensions=None), is_container='list', yang_name="slice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)""",
        })

    self.__slice = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slice(self):
    self.__slice = YANGDynClass(base=YANGListType("sliceid",yc_slice_sliceable_transceiver_sdm__transceiver_slice, yang_name="slice", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='sliceid', extensions=None), is_container='list', yang_name="slice", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='list', is_config=True)

  slice = __builtin__.property(_get_slice, _set_slice)


  _pyangbind_elements = OrderedDict([('slice', slice), ])


class sliceable_transceiver_sdm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sliceable-transceiver-sdm - based on the path /sliceable-transceiver-sdm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Latest update to sliceable transponder SDM YANG data model.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver',)

  _yang_name = 'sliceable-transceiver-sdm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver = YANGDynClass(base=yc_transceiver_sliceable_transceiver_sdm__transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_transceiver(self):
    """
    Getter method for transceiver, mapped from YANG variable /transceiver (container)
    """
    return self.__transceiver
      
  def _set_transceiver(self, v, load=False):
    """
    Setter method for transceiver, mapped from YANG variable /transceiver (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transceiver_sliceable_transceiver_sdm__transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transceiver_sliceable_transceiver_sdm__transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)""",
        })

    self.__transceiver = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver(self):
    self.__transceiver = YANGDynClass(base=yc_transceiver_sliceable_transceiver_sdm__transceiver, is_container='container', yang_name="transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:sliceable-transceiver-sdm', defining_module='sliceable-transceiver-sdm', yang_type='container', is_config=True)

  transceiver = __builtin__.property(_get_transceiver, _set_transceiver)


  _pyangbind_elements = OrderedDict([('transceiver', transceiver), ])


