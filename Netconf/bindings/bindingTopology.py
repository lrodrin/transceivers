# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__


class yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/available-frequency-slot/nominal-central-frequency. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__grid_type', '__adjustment_granularity', '__channel_number',)

    _yang_name = 'nominal-central-frequency'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'available-frequency-slot', u'nominal-central-frequency']

    def _get_grid_type(self):
        """
        Getter method for grid_type, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/grid_type (string)
        """
        return self.__grid_type

    def _set_grid_type(self, v, load=False):
        """
        Setter method for grid_type, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/grid_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grid_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grid_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """grid_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__grid_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_grid_type(self):
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

    def _get_adjustment_granularity(self):
        """
        Getter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        """
        return self.__adjustment_granularity

    def _set_adjustment_granularity(self, v, load=False):
        """
        Setter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_adjustment_granularity is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_adjustment_granularity() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """adjustment_granularity must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__adjustment_granularity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_adjustment_granularity(self):
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_channel_number(self):
        """
        Getter method for channel_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/channel_number (string)
        """
        return self.__channel_number

    def _set_channel_number(self, v, load=False):
        """
        Setter method for channel_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/channel_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_channel_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_channel_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """channel_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__channel_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_channel_number(self):
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    grid_type = __builtin__.property(_get_grid_type, _set_grid_type)
    adjustment_granularity = __builtin__.property(_get_adjustment_granularity, _set_adjustment_granularity)
    channel_number = __builtin__.property(_get_channel_number, _set_channel_number)

    _pyangbind_elements = OrderedDict([('grid_type', grid_type), ('adjustment_granularity', adjustment_granularity),
                                       ('channel_number', channel_number), ])


class yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/available-frequency-slot. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__slot_id', '__nominal_central_frequency', '__slot_width_number',)

    _yang_name = 'available-frequency-slot'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'available-frequency-slot']

    def _get_slot_id(self):
        """
        Getter method for slot_id, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_id (string)
        """
        return self.__slot_id

    def _set_slot_id(self, v, load=False):
        """
        Setter method for slot_id, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_id(self):
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_nominal_central_frequency(self):
        """
        Getter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency (container)
        """
        return self.__nominal_central_frequency

    def _set_nominal_central_frequency(self, v, load=False):
        """
        Setter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_nominal_central_frequency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_nominal_central_frequency() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
                             is_container='container', yang_name="nominal-central-frequency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nominal_central_frequency must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency, is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__nominal_central_frequency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nominal_central_frequency(self):
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_slot_width_number(self):
        """
        Getter method for slot_width_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_width_number (string)
        """
        return self.__slot_width_number

    def _set_slot_width_number(self, v, load=False):
        """
        Setter method for slot_width_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_width_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_width_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_width_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_width_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_width_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_width_number(self):
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

    slot_id = __builtin__.property(_get_slot_id, _set_slot_id)
    nominal_central_frequency = __builtin__.property(_get_nominal_central_frequency, _set_nominal_central_frequency)
    slot_width_number = __builtin__.property(_get_slot_width_number, _set_slot_width_number)

    _pyangbind_elements = OrderedDict([('slot_id', slot_id), ('nominal_central_frequency', nominal_central_frequency),
                                       ('slot_width_number', slot_width_number), ])


class yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/occupied-frequency-slot/nominal-central-frequency. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__grid_type', '__adjustment_granularity', '__channel_number',)

    _yang_name = 'nominal-central-frequency'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'occupied-frequency-slot', u'nominal-central-frequency']

    def _get_grid_type(self):
        """
        Getter method for grid_type, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/grid_type (string)
        """
        return self.__grid_type

    def _set_grid_type(self, v, load=False):
        """
        Setter method for grid_type, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/grid_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grid_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grid_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """grid_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__grid_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_grid_type(self):
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

    def _get_adjustment_granularity(self):
        """
        Getter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        """
        return self.__adjustment_granularity

    def _set_adjustment_granularity(self, v, load=False):
        """
        Setter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_adjustment_granularity is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_adjustment_granularity() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """adjustment_granularity must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__adjustment_granularity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_adjustment_granularity(self):
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_channel_number(self):
        """
        Getter method for channel_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/channel_number (string)
        """
        return self.__channel_number

    def _set_channel_number(self, v, load=False):
        """
        Setter method for channel_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/channel_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_channel_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_channel_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """channel_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__channel_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_channel_number(self):
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    grid_type = __builtin__.property(_get_grid_type, _set_grid_type)
    adjustment_granularity = __builtin__.property(_get_adjustment_granularity, _set_adjustment_granularity)
    channel_number = __builtin__.property(_get_channel_number, _set_channel_number)

    _pyangbind_elements = OrderedDict([('grid_type', grid_type), ('adjustment_granularity', adjustment_granularity),
                                       ('channel_number', channel_number), ])


class yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/occupied-frequency-slot. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__slot_id', '__nominal_central_frequency', '__slot_width_number',)

    _yang_name = 'occupied-frequency-slot'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'occupied-frequency-slot']

    def _get_slot_id(self):
        """
        Getter method for slot_id, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_id (string)
        """
        return self.__slot_id

    def _set_slot_id(self, v, load=False):
        """
        Setter method for slot_id, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_id(self):
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_nominal_central_frequency(self):
        """
        Getter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency (container)
        """
        return self.__nominal_central_frequency

    def _set_nominal_central_frequency(self, v, load=False):
        """
        Setter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_nominal_central_frequency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_nominal_central_frequency() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
                             is_container='container', yang_name="nominal-central-frequency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nominal_central_frequency must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency, is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__nominal_central_frequency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nominal_central_frequency(self):
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_slot_width_number(self):
        """
        Getter method for slot_width_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_width_number (string)
        """
        return self.__slot_width_number

    def _set_slot_width_number(self, v, load=False):
        """
        Setter method for slot_width_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_width_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_width_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_width_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_width_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_width_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_width_number(self):
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

    slot_id = __builtin__.property(_get_slot_id, _set_slot_id)
    nominal_central_frequency = __builtin__.property(_get_nominal_central_frequency, _set_nominal_central_frequency)
    slot_width_number = __builtin__.property(_get_slot_width_number, _set_slot_width_number)

    _pyangbind_elements = OrderedDict([('slot_id', slot_id), ('nominal_central_frequency', nominal_central_frequency),
                                       ('slot_width_number', slot_width_number), ])


class yc_available_core_node_topology__node_port_available_core(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__core_id', '__available_frequency_slot', '__occupied_frequency_slot',)

    _yang_name = 'available-core'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__core_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__available_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                         yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                                         yang_name="available-frequency-slot",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper,
                                                                         yang_keys='slot-id', extensions=None),
                                                       is_container='list', yang_name="available-frequency-slot",
                                                       parent=self, path_helper=self._path_helper,
                                                       extmethods=self._extmethods, register_paths=True,
                                                       extensions=None, namespace='urn:node-topology',
                                                       defining_module='node-topology', yang_type='list',
                                                       is_config=True)
        self.__occupied_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                        yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                                        yang_name="occupied-frequency-slot",
                                                                        parent=self, is_container='list',
                                                                        user_ordered=False,
                                                                        path_helper=self._path_helper,
                                                                        yang_keys='slot-id', extensions=None),
                                                      is_container='list', yang_name="occupied-frequency-slot",
                                                      parent=self, path_helper=self._path_helper,
                                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                                      namespace='urn:node-topology', defining_module='node-topology',
                                                      yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core']

    def _get_core_id(self):
        """
        Getter method for core_id, mapped from YANG variable /node/port/available_core/core_id (string)
        """
        return self.__core_id

    def _set_core_id(self, v, load=False):
        """
        Setter method for core_id, mapped from YANG variable /node/port/available_core/core_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_core_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_core_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """core_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__core_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_core_id(self):
        self.__core_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_available_frequency_slot(self):
        """
        Getter method for available_frequency_slot, mapped from YANG variable /node/port/available_core/available_frequency_slot (list)
        """
        return self.__available_frequency_slot

    def _set_available_frequency_slot(self, v, load=False):
        """
        Setter method for available_frequency_slot, mapped from YANG variable /node/port/available_core/available_frequency_slot (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_frequency_slot is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_frequency_slot() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("slot_id",
                                                  yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                  yang_name="available-frequency-slot", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='slot-id', extensions=None),
                             is_container='list', yang_name="available-frequency-slot", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_frequency_slot must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("slot_id",yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot, yang_name="available-frequency-slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions=None), is_container='list', yang_name="available-frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__available_frequency_slot = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_frequency_slot(self):
        self.__available_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                         yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                                         yang_name="available-frequency-slot",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper,
                                                                         yang_keys='slot-id', extensions=None),
                                                       is_container='list', yang_name="available-frequency-slot",
                                                       parent=self, path_helper=self._path_helper,
                                                       extmethods=self._extmethods, register_paths=True,
                                                       extensions=None, namespace='urn:node-topology',
                                                       defining_module='node-topology', yang_type='list',
                                                       is_config=True)

    def _get_occupied_frequency_slot(self):
        """
        Getter method for occupied_frequency_slot, mapped from YANG variable /node/port/available_core/occupied_frequency_slot (list)
        """
        return self.__occupied_frequency_slot

    def _set_occupied_frequency_slot(self, v, load=False):
        """
        Setter method for occupied_frequency_slot, mapped from YANG variable /node/port/available_core/occupied_frequency_slot (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_occupied_frequency_slot is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_occupied_frequency_slot() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("slot_id",
                                                  yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                  yang_name="occupied-frequency-slot", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='slot-id', extensions=None), is_container='list',
                             yang_name="occupied-frequency-slot", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """occupied_frequency_slot must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("slot_id",yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot, yang_name="occupied-frequency-slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions=None), is_container='list', yang_name="occupied-frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__occupied_frequency_slot = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_occupied_frequency_slot(self):
        self.__occupied_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                        yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                                        yang_name="occupied-frequency-slot",
                                                                        parent=self, is_container='list',
                                                                        user_ordered=False,
                                                                        path_helper=self._path_helper,
                                                                        yang_keys='slot-id', extensions=None),
                                                      is_container='list', yang_name="occupied-frequency-slot",
                                                      parent=self, path_helper=self._path_helper,
                                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                                      namespace='urn:node-topology', defining_module='node-topology',
                                                      yang_type='list', is_config=True)

    core_id = __builtin__.property(_get_core_id, _set_core_id)
    available_frequency_slot = __builtin__.property(_get_available_frequency_slot, _set_available_frequency_slot)
    occupied_frequency_slot = __builtin__.property(_get_occupied_frequency_slot, _set_occupied_frequency_slot)

    _pyangbind_elements = OrderedDict([('core_id', core_id), ('available_frequency_slot', available_frequency_slot),
                                       ('occupied_frequency_slot', occupied_frequency_slot), ])


class yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-modulation-format. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__modulation_id', '__mod_type',)

    _yang_name = 'supported-modulation-format'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mod_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:node-topology', defining_module='node-topology',
                                       yang_type='string', is_config=True)
        self.__modulation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-modulation-format']

    def _get_modulation_id(self):
        """
        Getter method for modulation_id, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/modulation_id (string)
        """
        return self.__modulation_id

    def _set_modulation_id(self, v, load=False):
        """
        Setter method for modulation_id, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/modulation_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_modulation_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_modulation_id() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """modulation_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__modulation_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_modulation_id(self):
        self.__modulation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

    def _get_mod_type(self):
        """
        Getter method for mod_type, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/mod_type (string)
        """
        return self.__mod_type

    def _set_mod_type(self, v, load=False):
        """
        Setter method for mod_type, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/mod_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mod_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mod_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mod_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__mod_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mod_type(self):
        self.__mod_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:node-topology', defining_module='node-topology',
                                       yang_type='string', is_config=True)

    modulation_id = __builtin__.property(_get_modulation_id, _set_modulation_id)
    mod_type = __builtin__.property(_get_mod_type, _set_mod_type)

    _pyangbind_elements = OrderedDict([('modulation_id', modulation_id), ('mod_type', mod_type), ])


class yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-center-frequency-range. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__max_cf', '__min_cf',)

    _yang_name = 'supported-center-frequency-range'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)
        self.__min_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-center-frequency-range']

    def _get_max_cf(self):
        """
        Getter method for max_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/max_cf (string)
        """
        return self.__max_cf

    def _set_max_cf(self, v, load=False):
        """
        Setter method for max_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/max_cf (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_cf is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_cf() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_cf must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__max_cf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_cf(self):
        self.__max_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    def _get_min_cf(self):
        """
        Getter method for min_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/min_cf (string)
        """
        return self.__min_cf

    def _set_min_cf(self, v, load=False):
        """
        Setter method for min_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/min_cf (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_cf is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_cf() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_cf must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__min_cf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_cf(self):
        self.__min_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    max_cf = __builtin__.property(_get_max_cf, _set_max_cf)
    min_cf = __builtin__.property(_get_min_cf, _set_min_cf)

    _pyangbind_elements = OrderedDict([('max_cf', max_cf), ('min_cf', min_cf), ])


class yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-bandwidth. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__max_bw', '__min_bw',)

    _yang_name = 'supported-bandwidth'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)
        self.__max_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-bandwidth']

    def _get_max_bw(self):
        """
        Getter method for max_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/max_bw (string)
        """
        return self.__max_bw

    def _set_max_bw(self, v, load=False):
        """
        Setter method for max_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/max_bw (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_bw is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_bw() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_bw must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__max_bw = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_bw(self):
        self.__max_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    def _get_min_bw(self):
        """
        Getter method for min_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/min_bw (string)
        """
        return self.__min_bw

    def _set_min_bw(self, v, load=False):
        """
        Setter method for min_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/min_bw (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_bw is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_bw() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_bw must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__min_bw = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_bw(self):
        self.__min_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    max_bw = __builtin__.property(_get_max_bw, _set_max_bw)
    min_bw = __builtin__.property(_get_min_bw, _set_min_bw)

    _pyangbind_elements = OrderedDict([('max_bw', max_bw), ('min_bw', min_bw), ])


class yc_available_transceiver_node_topology__node_port_available_transceiver(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = (
    '_path_helper', '_extmethods', '__transceiver_id', '__transceiver_type', '__supported_modulation_format',
    '__supported_center_frequency_range', '__supported_bandwidth', '__supported_FEC', '__supported_equalization',
    '__supported_monitoring',)

    _yang_name = 'available-transceiver'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__supported_bandwidth = YANGDynClass(
            base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
            is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__transceiver_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__supported_FEC = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)
        self.__transceiver_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:node-topology',
                                               defining_module='node-topology', yang_type='string', is_config=True)
        self.__supported_center_frequency_range = YANGDynClass(
            base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
            is_container='container', yang_name="supported-center-frequency-range", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)
        self.__supported_equalization = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="supported-equalization", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__supported_monitoring = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:node-topology', defining_module='node-topology',
                                                   yang_type='string', is_config=True)
        self.__supported_modulation_format = YANGDynClass(
            base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
            is_container='container', yang_name="supported-modulation-format", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver']

    def _get_transceiver_id(self):
        """
        Getter method for transceiver_id, mapped from YANG variable /node/port/available_transceiver/transceiver_id (string)
        """
        return self.__transceiver_id

    def _set_transceiver_id(self, v, load=False):
        """
        Setter method for transceiver_id, mapped from YANG variable /node/port/available_transceiver/transceiver_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transceiver_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transceiver_id() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """transceiver_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__transceiver_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_transceiver_id(self):
        self.__transceiver_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    def _get_transceiver_type(self):
        """
        Getter method for transceiver_type, mapped from YANG variable /node/port/available_transceiver/transceiver_type (string)
        """
        return self.__transceiver_type

    def _set_transceiver_type(self, v, load=False):
        """
        Setter method for transceiver_type, mapped from YANG variable /node/port/available_transceiver/transceiver_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transceiver_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transceiver_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="transceiver-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """transceiver_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__transceiver_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_transceiver_type(self):
        self.__transceiver_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:node-topology',
                                               defining_module='node-topology', yang_type='string', is_config=True)

    def _get_supported_modulation_format(self):
        """
        Getter method for supported_modulation_format, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format (container)
        """
        return self.__supported_modulation_format

    def _set_supported_modulation_format(self, v, load=False):
        """
        Setter method for supported_modulation_format, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_modulation_format is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_modulation_format() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
                             is_container='container', yang_name="supported-modulation-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_modulation_format must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format, is_container='container', yang_name="supported-modulation-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_modulation_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_modulation_format(self):
        self.__supported_modulation_format = YANGDynClass(
            base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
            is_container='container', yang_name="supported-modulation-format", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_center_frequency_range(self):
        """
        Getter method for supported_center_frequency_range, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range (container)
        """
        return self.__supported_center_frequency_range

    def _set_supported_center_frequency_range(self, v, load=False):
        """
        Setter method for supported_center_frequency_range, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_center_frequency_range is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_center_frequency_range() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
                             is_container='container', yang_name="supported-center-frequency-range", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_center_frequency_range must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range, is_container='container', yang_name="supported-center-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_center_frequency_range = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_center_frequency_range(self):
        self.__supported_center_frequency_range = YANGDynClass(
            base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
            is_container='container', yang_name="supported-center-frequency-range", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_bandwidth(self):
        """
        Getter method for supported_bandwidth, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth (container)
        """
        return self.__supported_bandwidth

    def _set_supported_bandwidth(self, v, load=False):
        """
        Setter method for supported_bandwidth, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_bandwidth is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_bandwidth() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
                             is_container='container', yang_name="supported-bandwidth", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_bandwidth must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth, is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_bandwidth = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_bandwidth(self):
        self.__supported_bandwidth = YANGDynClass(
            base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
            is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_FEC(self):
        """
        Getter method for supported_FEC, mapped from YANG variable /node/port/available_transceiver/supported_FEC (string)
        """
        return self.__supported_FEC

    def _set_supported_FEC(self, v, load=False):
        """
        Setter method for supported_FEC, mapped from YANG variable /node/port/available_transceiver/supported_FEC (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_FEC is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_FEC() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_FEC must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_FEC = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_FEC(self):
        self.__supported_FEC = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

    def _get_supported_equalization(self):
        """
        Getter method for supported_equalization, mapped from YANG variable /node/port/available_transceiver/supported_equalization (string)
        """
        return self.__supported_equalization

    def _set_supported_equalization(self, v, load=False):
        """
        Setter method for supported_equalization, mapped from YANG variable /node/port/available_transceiver/supported_equalization (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_equalization is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_equalization() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-equalization", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_equalization must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_equalization = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_equalization(self):
        self.__supported_equalization = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="supported-equalization", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_supported_monitoring(self):
        """
        Getter method for supported_monitoring, mapped from YANG variable /node/port/available_transceiver/supported_monitoring (string)
        """
        return self.__supported_monitoring

    def _set_supported_monitoring(self, v, load=False):
        """
        Setter method for supported_monitoring, mapped from YANG variable /node/port/available_transceiver/supported_monitoring (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_monitoring is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_monitoring() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-monitoring", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_monitoring must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_monitoring = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_monitoring(self):
        self.__supported_monitoring = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:node-topology', defining_module='node-topology',
                                                   yang_type='string', is_config=True)

    transceiver_id = __builtin__.property(_get_transceiver_id, _set_transceiver_id)
    transceiver_type = __builtin__.property(_get_transceiver_type, _set_transceiver_type)
    supported_modulation_format = __builtin__.property(_get_supported_modulation_format,
                                                       _set_supported_modulation_format)
    supported_center_frequency_range = __builtin__.property(_get_supported_center_frequency_range,
                                                            _set_supported_center_frequency_range)
    supported_bandwidth = __builtin__.property(_get_supported_bandwidth, _set_supported_bandwidth)
    supported_FEC = __builtin__.property(_get_supported_FEC, _set_supported_FEC)
    supported_equalization = __builtin__.property(_get_supported_equalization, _set_supported_equalization)
    supported_monitoring = __builtin__.property(_get_supported_monitoring, _set_supported_monitoring)

    _pyangbind_elements = OrderedDict([('transceiver_id', transceiver_id), ('transceiver_type', transceiver_type),
                                       ('supported_modulation_format', supported_modulation_format),
                                       ('supported_center_frequency_range', supported_center_frequency_range),
                                       ('supported_bandwidth', supported_bandwidth), ('supported_FEC', supported_FEC),
                                       ('supported_equalization', supported_equalization),
                                       ('supported_monitoring', supported_monitoring), ])


class yc_port_node_topology__node_port(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = (
    '_path_helper', '_extmethods', '__port_id', '__layer_protocol_name', '__available_core', '__available_transceiver',)

    _yang_name = 'port'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__available_transceiver = YANGDynClass(
            base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container',
            yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='container', is_config=True)
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                              yang_name="available-core", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list',
            yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port']

    def _get_port_id(self):
        """
        Getter method for port_id, mapped from YANG variable /node/port/port_id (string)
        """
        return self.__port_id

    def _set_port_id(self, v, load=False):
        """
        Setter method for port_id, mapped from YANG variable /node/port/port_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_port_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_port_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__port_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_id(self):
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_layer_protocol_name(self):
        """
        Getter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        """
        return self.__layer_protocol_name

    def _set_layer_protocol_name(self, v, load=False):
        """
        Setter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_layer_protocol_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_layer_protocol_name() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__layer_protocol_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol_name(self):
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)

    def _get_available_core(self):
        """
        Getter method for available_core, mapped from YANG variable /node/port/available_core (list)
        """
        return self.__available_core

    def _set_available_core(self, v, load=False):
        """
        Setter method for available_core, mapped from YANG variable /node/port/available_core (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_core is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_core() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                                                  yang_name="available-core", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='core-id', extensions=None), is_container='list',
                             yang_name="available-core", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_core must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("core_id",yc_available_core_node_topology__node_port_available_core, yang_name="available-core", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list', yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__available_core = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_core(self):
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                              yang_name="available-core", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list',
            yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='list', is_config=True)

    def _get_available_transceiver(self):
        """
        Getter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        """
        return self.__available_transceiver

    def _set_available_transceiver(self, v, load=False):
        """
        Setter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_transceiver is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_transceiver() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_available_transceiver_node_topology__node_port_available_transceiver,
                             is_container='container', yang_name="available-transceiver", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_transceiver must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container', yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__available_transceiver = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_transceiver(self):
        self.__available_transceiver = YANGDynClass(
            base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container',
            yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='container', is_config=True)

    port_id = __builtin__.property(_get_port_id, _set_port_id)
    layer_protocol_name = __builtin__.property(_get_layer_protocol_name, _set_layer_protocol_name)
    available_core = __builtin__.property(_get_available_core, _set_available_core)
    available_transceiver = __builtin__.property(_get_available_transceiver, _set_available_transceiver)

    _pyangbind_elements = OrderedDict(
        [('port_id', port_id), ('layer_protocol_name', layer_protocol_name), ('available_core', available_core),
         ('available_transceiver', available_transceiver), ])


class yc_node_node_topology__node(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__node_id', '__port',)

    _yang_name = 'node'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__port = YANGDynClass(
            base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node']

    def _get_node_id(self):
        """
        Getter method for node_id, mapped from YANG variable /node/node_id (string)
        """
        return self.__node_id

    def _set_node_id(self, v, load=False):
        """
        Setter method for node_id, mapped from YANG variable /node/node_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_node_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_node_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__node_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node_id(self):
        self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_port(self):
        """
        Getter method for port, mapped from YANG variable /node/port (list)
        """
        return self.__port

    def _set_port(self, v, load=False):
        """
        Setter method for port, mapped from YANG variable /node/port (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_port() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='port-id', extensions=None),
                             is_container='list', yang_name="port", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("port_id",yc_port_node_topology__node_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__port = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port(self):
        self.__port = YANGDynClass(
            base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

    node_id = __builtin__.property(_get_node_id, _set_node_id)
    port = __builtin__.property(_get_port, _set_port)

    _pyangbind_elements = OrderedDict([('node_id', node_id), ('port', port), ])


class node_topology(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node-topology. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Latest update to node topology SDM YANG data model.
    """
    __slots__ = ('_path_helper', '_extmethods', '__node',)

    _yang_name = 'node-topology'
    _yang_namespace = 'urn:node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node = YANGDynClass(
            base=YANGListType("node_id", yc_node_node_topology__node, yang_name="node", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_node(self):
        """
        Getter method for node, mapped from YANG variable /node (list)
        """
        return self.__node

    def _set_node(self, v, load=False):
        """
        Setter method for node, mapped from YANG variable /node (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_node is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_node() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("node_id", yc_node_node_topology__node, yang_name="node", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='node-id', extensions=None),
                             is_container='list', yang_name="node", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("node_id",yc_node_node_topology__node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__node = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node(self):
        self.__node = YANGDynClass(
            base=YANGListType("node_id", yc_node_node_topology__node, yang_name="node", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

    node = __builtin__.property(_get_node, _set_node)

    _pyangbind_elements = OrderedDict([('node', node), ])
