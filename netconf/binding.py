# -*- coding: utf-8 -*-
from collections import OrderedDict

import six
from pyangbind.lib.base import PybindBase
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import YANGListType

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__


class yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/available-frequency-slot/nominal-central-frequency. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__grid_type', '__adjustment_granularity', '__channel_number',)

    _yang_name = 'nominal-central-frequency'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'available-frequency-slot', u'nominal-central-frequency']

    def _get_grid_type(self):
        """
        Getter method for grid_type, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/grid_type (string)
        """
        return self.__grid_type

    def _set_grid_type(self, v, load=False):
        """
        Setter method for grid_type, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/grid_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grid_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grid_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """grid_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__grid_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_grid_type(self):
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

    def _get_adjustment_granularity(self):
        """
        Getter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        """
        return self.__adjustment_granularity

    def _set_adjustment_granularity(self, v, load=False):
        """
        Setter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_adjustment_granularity is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_adjustment_granularity() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """adjustment_granularity must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__adjustment_granularity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_adjustment_granularity(self):
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_channel_number(self):
        """
        Getter method for channel_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/channel_number (string)
        """
        return self.__channel_number

    def _set_channel_number(self, v, load=False):
        """
        Setter method for channel_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency/channel_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_channel_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_channel_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """channel_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__channel_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_channel_number(self):
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    grid_type = __builtin__.property(_get_grid_type, _set_grid_type)
    adjustment_granularity = __builtin__.property(_get_adjustment_granularity, _set_adjustment_granularity)
    channel_number = __builtin__.property(_get_channel_number, _set_channel_number)

    _pyangbind_elements = OrderedDict([('grid_type', grid_type), ('adjustment_granularity', adjustment_granularity),
                                       ('channel_number', channel_number), ])


class yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/available-frequency-slot. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__slot_id', '__nominal_central_frequency', '__slot_width_number',)

    _yang_name = 'available-frequency-slot'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'available-frequency-slot']

    def _get_slot_id(self):
        """
        Getter method for slot_id, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_id (string)
        """
        return self.__slot_id

    def _set_slot_id(self, v, load=False):
        """
        Setter method for slot_id, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_id(self):
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_nominal_central_frequency(self):
        """
        Getter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency (container)
        """
        return self.__nominal_central_frequency

    def _set_nominal_central_frequency(self, v, load=False):
        """
        Setter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/available_frequency_slot/nominal_central_frequency (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_nominal_central_frequency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_nominal_central_frequency() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
                             is_container='container', yang_name="nominal-central-frequency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nominal_central_frequency must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency, is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__nominal_central_frequency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nominal_central_frequency(self):
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_available_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_slot_width_number(self):
        """
        Getter method for slot_width_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_width_number (string)
        """
        return self.__slot_width_number

    def _set_slot_width_number(self, v, load=False):
        """
        Setter method for slot_width_number, mapped from YANG variable /node/port/available_core/available_frequency_slot/slot_width_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_width_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_width_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_width_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_width_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_width_number(self):
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

    slot_id = __builtin__.property(_get_slot_id, _set_slot_id)
    nominal_central_frequency = __builtin__.property(_get_nominal_central_frequency, _set_nominal_central_frequency)
    slot_width_number = __builtin__.property(_get_slot_width_number, _set_slot_width_number)

    _pyangbind_elements = OrderedDict([('slot_id', slot_id), ('nominal_central_frequency', nominal_central_frequency),
                                       ('slot_width_number', slot_width_number), ])


class yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/occupied-frequency-slot/nominal-central-frequency. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__grid_type', '__adjustment_granularity', '__channel_number',)

    _yang_name = 'nominal-central-frequency'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'occupied-frequency-slot', u'nominal-central-frequency']

    def _get_grid_type(self):
        """
        Getter method for grid_type, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/grid_type (string)
        """
        return self.__grid_type

    def _set_grid_type(self, v, load=False):
        """
        Setter method for grid_type, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/grid_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_grid_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_grid_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """grid_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__grid_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_grid_type(self):
        self.__grid_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="grid-type", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:node-topology', defining_module='node-topology',
                                        yang_type='string', is_config=True)

    def _get_adjustment_granularity(self):
        """
        Getter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        """
        return self.__adjustment_granularity

    def _set_adjustment_granularity(self, v, load=False):
        """
        Setter method for adjustment_granularity, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/adjustment_granularity (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_adjustment_granularity is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_adjustment_granularity() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """adjustment_granularity must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="adjustment-granularity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__adjustment_granularity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_adjustment_granularity(self):
        self.__adjustment_granularity = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="adjustment-granularity", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_channel_number(self):
        """
        Getter method for channel_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/channel_number (string)
        """
        return self.__channel_number

    def _set_channel_number(self, v, load=False):
        """
        Setter method for channel_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency/channel_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_channel_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_channel_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """channel_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__channel_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_channel_number(self):
        self.__channel_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channel-number", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    grid_type = __builtin__.property(_get_grid_type, _set_grid_type)
    adjustment_granularity = __builtin__.property(_get_adjustment_granularity, _set_adjustment_granularity)
    channel_number = __builtin__.property(_get_channel_number, _set_channel_number)

    _pyangbind_elements = OrderedDict([('grid_type', grid_type), ('adjustment_granularity', adjustment_granularity),
                                       ('channel_number', channel_number), ])


class yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core/occupied-frequency-slot. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__slot_id', '__nominal_central_frequency', '__slot_width_number',)

    _yang_name = 'occupied-frequency-slot'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core', u'occupied-frequency-slot']

    def _get_slot_id(self):
        """
        Getter method for slot_id, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_id (string)
        """
        return self.__slot_id

    def _set_slot_id(self, v, load=False):
        """
        Setter method for slot_id, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_id(self):
        self.__slot_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_nominal_central_frequency(self):
        """
        Getter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency (container)
        """
        return self.__nominal_central_frequency

    def _set_nominal_central_frequency(self, v, load=False):
        """
        Setter method for nominal_central_frequency, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/nominal_central_frequency (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_nominal_central_frequency is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_nominal_central_frequency() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
                             is_container='container', yang_name="nominal-central-frequency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nominal_central_frequency must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency, is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__nominal_central_frequency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nominal_central_frequency(self):
        self.__nominal_central_frequency = YANGDynClass(
            base=yc_nominal_central_frequency_node_topology__node_port_available_core_occupied_frequency_slot_nominal_central_frequency,
            is_container='container', yang_name="nominal-central-frequency", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_slot_width_number(self):
        """
        Getter method for slot_width_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_width_number (string)
        """
        return self.__slot_width_number

    def _set_slot_width_number(self, v, load=False):
        """
        Setter method for slot_width_number, mapped from YANG variable /node/port/available_core/occupied_frequency_slot/slot_width_number (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_slot_width_number is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_slot_width_number() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """slot_width_number must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__slot_width_number = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_slot_width_number(self):
        self.__slot_width_number = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slot-width-number",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:node-topology',
                                                defining_module='node-topology', yang_type='string', is_config=True)

    slot_id = __builtin__.property(_get_slot_id, _set_slot_id)
    nominal_central_frequency = __builtin__.property(_get_nominal_central_frequency, _set_nominal_central_frequency)
    slot_width_number = __builtin__.property(_get_slot_width_number, _set_slot_width_number)

    _pyangbind_elements = OrderedDict([('slot_id', slot_id), ('nominal_central_frequency', nominal_central_frequency),
                                       ('slot_width_number', slot_width_number), ])


class yc_available_core_node_topology__node_port_available_core(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-core. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__core_id', '__available_frequency_slot', '__occupied_frequency_slot',)

    _yang_name = 'available-core'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__core_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__available_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                         yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                                         yang_name="available-frequency-slot",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper,
                                                                         yang_keys='slot-id', extensions=None),
                                                       is_container='list', yang_name="available-frequency-slot",
                                                       parent=self, path_helper=self._path_helper,
                                                       extmethods=self._extmethods, register_paths=True,
                                                       extensions=None, namespace='urn:node-topology',
                                                       defining_module='node-topology', yang_type='list',
                                                       is_config=True)
        self.__occupied_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                        yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                                        yang_name="occupied-frequency-slot",
                                                                        parent=self, is_container='list',
                                                                        user_ordered=False,
                                                                        path_helper=self._path_helper,
                                                                        yang_keys='slot-id', extensions=None),
                                                      is_container='list', yang_name="occupied-frequency-slot",
                                                      parent=self, path_helper=self._path_helper,
                                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                                      namespace='urn:node-topology', defining_module='node-topology',
                                                      yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-core']

    def _get_core_id(self):
        """
        Getter method for core_id, mapped from YANG variable /node/port/available_core/core_id (string)
        """
        return self.__core_id

    def _set_core_id(self, v, load=False):
        """
        Setter method for core_id, mapped from YANG variable /node/port/available_core/core_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_core_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_core_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """core_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__core_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_core_id(self):
        self.__core_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="core-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_available_frequency_slot(self):
        """
        Getter method for available_frequency_slot, mapped from YANG variable /node/port/available_core/available_frequency_slot (list)
        """
        return self.__available_frequency_slot

    def _set_available_frequency_slot(self, v, load=False):
        """
        Setter method for available_frequency_slot, mapped from YANG variable /node/port/available_core/available_frequency_slot (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_frequency_slot is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_frequency_slot() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("slot_id",
                                                  yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                  yang_name="available-frequency-slot", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='slot-id', extensions=None),
                             is_container='list', yang_name="available-frequency-slot", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_frequency_slot must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("slot_id",yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot, yang_name="available-frequency-slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions=None), is_container='list', yang_name="available-frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__available_frequency_slot = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_frequency_slot(self):
        self.__available_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                         yc_available_frequency_slot_node_topology__node_port_available_core_available_frequency_slot,
                                                                         yang_name="available-frequency-slot",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper,
                                                                         yang_keys='slot-id', extensions=None),
                                                       is_container='list', yang_name="available-frequency-slot",
                                                       parent=self, path_helper=self._path_helper,
                                                       extmethods=self._extmethods, register_paths=True,
                                                       extensions=None, namespace='urn:node-topology',
                                                       defining_module='node-topology', yang_type='list',
                                                       is_config=True)

    def _get_occupied_frequency_slot(self):
        """
        Getter method for occupied_frequency_slot, mapped from YANG variable /node/port/available_core/occupied_frequency_slot (list)
        """
        return self.__occupied_frequency_slot

    def _set_occupied_frequency_slot(self, v, load=False):
        """
        Setter method for occupied_frequency_slot, mapped from YANG variable /node/port/available_core/occupied_frequency_slot (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_occupied_frequency_slot is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_occupied_frequency_slot() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("slot_id",
                                                  yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                  yang_name="occupied-frequency-slot", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='slot-id', extensions=None), is_container='list',
                             yang_name="occupied-frequency-slot", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """occupied_frequency_slot must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("slot_id",yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot, yang_name="occupied-frequency-slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='slot-id', extensions=None), is_container='list', yang_name="occupied-frequency-slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__occupied_frequency_slot = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_occupied_frequency_slot(self):
        self.__occupied_frequency_slot = YANGDynClass(base=YANGListType("slot_id",
                                                                        yc_occupied_frequency_slot_node_topology__node_port_available_core_occupied_frequency_slot,
                                                                        yang_name="occupied-frequency-slot",
                                                                        parent=self, is_container='list',
                                                                        user_ordered=False,
                                                                        path_helper=self._path_helper,
                                                                        yang_keys='slot-id', extensions=None),
                                                      is_container='list', yang_name="occupied-frequency-slot",
                                                      parent=self, path_helper=self._path_helper,
                                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                                      namespace='urn:node-topology', defining_module='node-topology',
                                                      yang_type='list', is_config=True)

    core_id = __builtin__.property(_get_core_id, _set_core_id)
    available_frequency_slot = __builtin__.property(_get_available_frequency_slot, _set_available_frequency_slot)
    occupied_frequency_slot = __builtin__.property(_get_occupied_frequency_slot, _set_occupied_frequency_slot)

    _pyangbind_elements = OrderedDict([('core_id', core_id), ('available_frequency_slot', available_frequency_slot),
                                       ('occupied_frequency_slot', occupied_frequency_slot), ])


class yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-modulation-format. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__modulation_id', '__mod_type',)

    _yang_name = 'supported-modulation-format'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mod_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:node-topology', defining_module='node-topology',
                                       yang_type='string', is_config=True)
        self.__modulation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-modulation-format']

    def _get_modulation_id(self):
        """
        Getter method for modulation_id, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/modulation_id (string)
        """
        return self.__modulation_id

    def _set_modulation_id(self, v, load=False):
        """
        Setter method for modulation_id, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/modulation_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_modulation_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_modulation_id() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """modulation_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__modulation_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_modulation_id(self):
        self.__modulation_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="modulation-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

    def _get_mod_type(self):
        """
        Getter method for mod_type, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/mod_type (string)
        """
        return self.__mod_type

    def _set_mod_type(self, v, load=False):
        """
        Setter method for mod_type, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format/mod_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_mod_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_mod_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mod_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__mod_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mod_type(self):
        self.__mod_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mod-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:node-topology', defining_module='node-topology',
                                       yang_type='string', is_config=True)

    modulation_id = __builtin__.property(_get_modulation_id, _set_modulation_id)
    mod_type = __builtin__.property(_get_mod_type, _set_mod_type)

    _pyangbind_elements = OrderedDict([('modulation_id', modulation_id), ('mod_type', mod_type), ])


class yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range(
    PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-center-frequency-range. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__max_cf', '__min_cf',)

    _yang_name = 'supported-center-frequency-range'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)
        self.__min_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-center-frequency-range']

    def _get_max_cf(self):
        """
        Getter method for max_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/max_cf (string)
        """
        return self.__max_cf

    def _set_max_cf(self, v, load=False):
        """
        Setter method for max_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/max_cf (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_cf is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_cf() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_cf must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__max_cf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_cf(self):
        self.__max_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    def _get_min_cf(self):
        """
        Getter method for min_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/min_cf (string)
        """
        return self.__min_cf

    def _set_min_cf(self, v, load=False):
        """
        Setter method for min_cf, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range/min_cf (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_cf is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_cf() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_cf must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__min_cf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_cf(self):
        self.__min_cf = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-cf", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    max_cf = __builtin__.property(_get_max_cf, _set_max_cf)
    min_cf = __builtin__.property(_get_min_cf, _set_min_cf)

    _pyangbind_elements = OrderedDict([('max_cf', max_cf), ('min_cf', min_cf), ])


class yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver/supported-bandwidth. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__max_bw', '__min_bw',)

    _yang_name = 'supported-bandwidth'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)
        self.__max_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver', u'supported-bandwidth']

    def _get_max_bw(self):
        """
        Getter method for max_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/max_bw (string)
        """
        return self.__max_bw

    def _set_max_bw(self, v, load=False):
        """
        Setter method for max_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/max_bw (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_max_bw is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_max_bw() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_bw must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__max_bw = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_bw(self):
        self.__max_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="max-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    def _get_min_bw(self):
        """
        Getter method for min_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/min_bw (string)
        """
        return self.__min_bw

    def _set_min_bw(self, v, load=False):
        """
        Setter method for min_bw, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth/min_bw (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_min_bw is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_min_bw() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_bw must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__min_bw = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_bw(self):
        self.__min_bw = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-bw", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                                     is_config=True)

    max_bw = __builtin__.property(_get_max_bw, _set_max_bw)
    min_bw = __builtin__.property(_get_min_bw, _set_min_bw)

    _pyangbind_elements = OrderedDict([('max_bw', max_bw), ('min_bw', min_bw), ])


class yc_available_transceiver_node_topology__node_port_available_transceiver(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port/available-transceiver. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = (
    '_path_helper', '_extmethods', '__transceiver_id', '__transceiver_type', '__supported_modulation_format',
    '__supported_center_frequency_range', '__supported_bandwidth', '__supported_FEC', '__supported_equalization',
    '__supported_monitoring',)

    _yang_name = 'available-transceiver'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__supported_bandwidth = YANGDynClass(
            base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
            is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)
        self.__transceiver_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)
        self.__supported_FEC = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)
        self.__transceiver_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:node-topology',
                                               defining_module='node-topology', yang_type='string', is_config=True)
        self.__supported_center_frequency_range = YANGDynClass(
            base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
            is_container='container', yang_name="supported-center-frequency-range", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)
        self.__supported_equalization = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="supported-equalization", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)
        self.__supported_monitoring = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:node-topology', defining_module='node-topology',
                                                   yang_type='string', is_config=True)
        self.__supported_modulation_format = YANGDynClass(
            base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
            is_container='container', yang_name="supported-modulation-format", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port', u'available-transceiver']

    def _get_transceiver_id(self):
        """
        Getter method for transceiver_id, mapped from YANG variable /node/port/available_transceiver/transceiver_id (string)
        """
        return self.__transceiver_id

    def _set_transceiver_id(self, v, load=False):
        """
        Setter method for transceiver_id, mapped from YANG variable /node/port/available_transceiver/transceiver_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transceiver_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transceiver_id() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """transceiver_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__transceiver_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_transceiver_id(self):
        self.__transceiver_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:node-topology',
                                             defining_module='node-topology', yang_type='string', is_config=True)

    def _get_transceiver_type(self):
        """
        Getter method for transceiver_type, mapped from YANG variable /node/port/available_transceiver/transceiver_type (string)
        """
        return self.__transceiver_type

    def _set_transceiver_type(self, v, load=False):
        """
        Setter method for transceiver_type, mapped from YANG variable /node/port/available_transceiver/transceiver_type (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_transceiver_type is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_transceiver_type() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="transceiver-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """transceiver_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__transceiver_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_transceiver_type(self):
        self.__transceiver_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="transceiver-type",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:node-topology',
                                               defining_module='node-topology', yang_type='string', is_config=True)

    def _get_supported_modulation_format(self):
        """
        Getter method for supported_modulation_format, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format (container)
        """
        return self.__supported_modulation_format

    def _set_supported_modulation_format(self, v, load=False):
        """
        Setter method for supported_modulation_format, mapped from YANG variable /node/port/available_transceiver/supported_modulation_format (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_modulation_format is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_modulation_format() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
                             is_container='container', yang_name="supported-modulation-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_modulation_format must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format, is_container='container', yang_name="supported-modulation-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_modulation_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_modulation_format(self):
        self.__supported_modulation_format = YANGDynClass(
            base=yc_supported_modulation_format_node_topology__node_port_available_transceiver_supported_modulation_format,
            is_container='container', yang_name="supported-modulation-format", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_center_frequency_range(self):
        """
        Getter method for supported_center_frequency_range, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range (container)
        """
        return self.__supported_center_frequency_range

    def _set_supported_center_frequency_range(self, v, load=False):
        """
        Setter method for supported_center_frequency_range, mapped from YANG variable /node/port/available_transceiver/supported_center_frequency_range (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_center_frequency_range is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_center_frequency_range() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
                             is_container='container', yang_name="supported-center-frequency-range", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_center_frequency_range must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range, is_container='container', yang_name="supported-center-frequency-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_center_frequency_range = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_center_frequency_range(self):
        self.__supported_center_frequency_range = YANGDynClass(
            base=yc_supported_center_frequency_range_node_topology__node_port_available_transceiver_supported_center_frequency_range,
            is_container='container', yang_name="supported-center-frequency-range", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_bandwidth(self):
        """
        Getter method for supported_bandwidth, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth (container)
        """
        return self.__supported_bandwidth

    def _set_supported_bandwidth(self, v, load=False):
        """
        Setter method for supported_bandwidth, mapped from YANG variable /node/port/available_transceiver/supported_bandwidth (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_bandwidth is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_bandwidth() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
                             is_container='container', yang_name="supported-bandwidth", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_bandwidth must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth, is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__supported_bandwidth = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_bandwidth(self):
        self.__supported_bandwidth = YANGDynClass(
            base=yc_supported_bandwidth_node_topology__node_port_available_transceiver_supported_bandwidth,
            is_container='container', yang_name="supported-bandwidth", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology',
            defining_module='node-topology', yang_type='container', is_config=True)

    def _get_supported_FEC(self):
        """
        Getter method for supported_FEC, mapped from YANG variable /node/port/available_transceiver/supported_FEC (string)
        """
        return self.__supported_FEC

    def _set_supported_FEC(self, v, load=False):
        """
        Setter method for supported_FEC, mapped from YANG variable /node/port/available_transceiver/supported_FEC (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_FEC is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_FEC() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_FEC must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_FEC = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_FEC(self):
        self.__supported_FEC = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-FEC", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:node-topology',
                                            defining_module='node-topology', yang_type='string', is_config=True)

    def _get_supported_equalization(self):
        """
        Getter method for supported_equalization, mapped from YANG variable /node/port/available_transceiver/supported_equalization (string)
        """
        return self.__supported_equalization

    def _set_supported_equalization(self, v, load=False):
        """
        Setter method for supported_equalization, mapped from YANG variable /node/port/available_transceiver/supported_equalization (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_equalization is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_equalization() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-equalization", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_equalization must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-equalization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_equalization = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_equalization(self):
        self.__supported_equalization = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="supported-equalization", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:node-topology',
                                                     defining_module='node-topology', yang_type='string',
                                                     is_config=True)

    def _get_supported_monitoring(self):
        """
        Getter method for supported_monitoring, mapped from YANG variable /node/port/available_transceiver/supported_monitoring (string)
        """
        return self.__supported_monitoring

    def _set_supported_monitoring(self, v, load=False):
        """
        Setter method for supported_monitoring, mapped from YANG variable /node/port/available_transceiver/supported_monitoring (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_supported_monitoring is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_supported_monitoring() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="supported-monitoring", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_monitoring must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__supported_monitoring = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_monitoring(self):
        self.__supported_monitoring = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="supported-monitoring",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:node-topology', defining_module='node-topology',
                                                   yang_type='string', is_config=True)

    transceiver_id = __builtin__.property(_get_transceiver_id, _set_transceiver_id)
    transceiver_type = __builtin__.property(_get_transceiver_type, _set_transceiver_type)
    supported_modulation_format = __builtin__.property(_get_supported_modulation_format,
                                                       _set_supported_modulation_format)
    supported_center_frequency_range = __builtin__.property(_get_supported_center_frequency_range,
                                                            _set_supported_center_frequency_range)
    supported_bandwidth = __builtin__.property(_get_supported_bandwidth, _set_supported_bandwidth)
    supported_FEC = __builtin__.property(_get_supported_FEC, _set_supported_FEC)
    supported_equalization = __builtin__.property(_get_supported_equalization, _set_supported_equalization)
    supported_monitoring = __builtin__.property(_get_supported_monitoring, _set_supported_monitoring)

    _pyangbind_elements = OrderedDict([('transceiver_id', transceiver_id), ('transceiver_type', transceiver_type),
                                       ('supported_modulation_format', supported_modulation_format),
                                       ('supported_center_frequency_range', supported_center_frequency_range),
                                       ('supported_bandwidth', supported_bandwidth), ('supported_FEC', supported_FEC),
                                       ('supported_equalization', supported_equalization),
                                       ('supported_monitoring', supported_monitoring), ])


class yc_port_node_topology__node_port(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node/port. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = (
    '_path_helper', '_extmethods', '__port_id', '__layer_protocol_name', '__available_core', '__available_transceiver',)

    _yang_name = 'port'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__available_transceiver = YANGDynClass(
            base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container',
            yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='container', is_config=True)
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                              yang_name="available-core", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list',
            yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node', u'port']

    def _get_port_id(self):
        """
        Getter method for port_id, mapped from YANG variable /node/port/port_id (string)
        """
        return self.__port_id

    def _set_port_id(self, v, load=False):
        """
        Setter method for port_id, mapped from YANG variable /node/port/port_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_port_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_port_id() directly.
        """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__port_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_id(self):
        self.__port_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="port-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_layer_protocol_name(self):
        """
        Getter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        """
        return self.__layer_protocol_name

    def _set_layer_protocol_name(self, v, load=False):
        """
        Setter method for layer_protocol_name, mapped from YANG variable /node/port/layer_protocol_name (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_layer_protocol_name is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_layer_protocol_name() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__layer_protocol_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol_name(self):
        self.__layer_protocol_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="layer-protocol-name",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:node-topology', defining_module='node-topology',
                                                  yang_type='string', is_config=True)

    def _get_available_core(self):
        """
        Getter method for available_core, mapped from YANG variable /node/port/available_core (list)
        """
        return self.__available_core

    def _set_available_core(self, v, load=False):
        """
        Setter method for available_core, mapped from YANG variable /node/port/available_core (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_core is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_core() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                                                  yang_name="available-core", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='core-id', extensions=None), is_container='list',
                             yang_name="available-core", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_core must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("core_id",yc_available_core_node_topology__node_port_available_core, yang_name="available-core", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list', yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__available_core = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_core(self):
        self.__available_core = YANGDynClass(
            base=YANGListType("core_id", yc_available_core_node_topology__node_port_available_core,
                              yang_name="available-core", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='core-id', extensions=None), is_container='list',
            yang_name="available-core", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='list', is_config=True)

    def _get_available_transceiver(self):
        """
        Getter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        """
        return self.__available_transceiver

    def _set_available_transceiver(self, v, load=False):
        """
        Setter method for available_transceiver, mapped from YANG variable /node/port/available_transceiver (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_available_transceiver is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_available_transceiver() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_available_transceiver_node_topology__node_port_available_transceiver,
                             is_container='container', yang_name="available-transceiver", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:node-topology', defining_module='node-topology',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """available_transceiver must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container', yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__available_transceiver = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_available_transceiver(self):
        self.__available_transceiver = YANGDynClass(
            base=yc_available_transceiver_node_topology__node_port_available_transceiver, is_container='container',
            yang_name="available-transceiver", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology',
            yang_type='container', is_config=True)

    port_id = __builtin__.property(_get_port_id, _set_port_id)
    layer_protocol_name = __builtin__.property(_get_layer_protocol_name, _set_layer_protocol_name)
    available_core = __builtin__.property(_get_available_core, _set_available_core)
    available_transceiver = __builtin__.property(_get_available_transceiver, _set_available_transceiver)

    _pyangbind_elements = OrderedDict(
        [('port_id', port_id), ('layer_protocol_name', layer_protocol_name), ('available_core', available_core),
         ('available_transceiver', available_transceiver), ])


class yc_node_node_topology__node(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.
    """
    __slots__ = ('_path_helper', '_extmethods', '__node_id', '__port',)

    _yang_name = 'node'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)
        self.__port = YANGDynClass(
            base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'node']

    def _get_node_id(self):
        """
        Getter method for node_id, mapped from YANG variable /node/node_id (string)
        """
        return self.__node_id

    def _set_node_id(self, v, load=False):
        """
        Setter method for node_id, mapped from YANG variable /node/node_id (string)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_node_id is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_node_id() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:node-topology', defining_module='node-topology', yang_type='string', is_config=True)""",
            })

        self.__node_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node_id(self):
        self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:node-topology', defining_module='node-topology',
                                      yang_type='string', is_config=True)

    def _get_port(self):
        """
        Getter method for port, mapped from YANG variable /node/port (list)
        """
        return self.__port

    def _set_port(self, v, load=False):
        """
        Setter method for port, mapped from YANG variable /node/port (list)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_port is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_port() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='port-id', extensions=None),
                             is_container='list', yang_name="port", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:node-topology', defining_module='node-topology', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("port_id",yc_port_node_topology__node_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)""",
            })

        self.__port = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port(self):
        self.__port = YANGDynClass(
            base=YANGListType("port_id", yc_port_node_topology__node_port, yang_name="port", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='port-id', extensions=None), is_container='list', yang_name="port", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:node-topology', defining_module='node-topology', yang_type='list', is_config=True)

    node_id = __builtin__.property(_get_node_id, _set_node_id)
    port = __builtin__.property(_get_port, _set_port)

    _pyangbind_elements = OrderedDict([('node_id', node_id), ('port', port), ])


class node_topology(PybindBase):
    """
    This class was auto-generated by the PythonClass plugin for PYANG
    from YANG module node-topology - based on the path /node-topology. Each member element of
    the container is represented as a class variable - with a specific
    YANG type.

    YANG Description: Latest update to node topology SDM YANG data model.
    """
    __slots__ = ('_path_helper', '_extmethods', '__node',)

    _yang_name = 'node-topology'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node = YANGDynClass(base=yc_node_node_topology__node, is_container='container', yang_name="node",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:node-topology',
                                   defining_module='node-topology', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_node(self):
        """
        Getter method for node, mapped from YANG variable /node (container)
        """
        return self.__node

    def _set_node(self, v, load=False):
        """
        Setter method for node, mapped from YANG variable /node (container)
        If this variable is read-only (config: false) in the
        source YANG file, then _set_node is considered as a private
        method. Backends looking to populate this variable should
        do so via calling thisObj._set_node() directly.
        """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_node_node_topology__node, is_container='container', yang_name="node",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:node-topology',
                             defining_module='node-topology', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_node_node_topology__node, is_container='container', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:node-topology', defining_module='node-topology', yang_type='container', is_config=True)""",
            })

        self.__node = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node(self):
        self.__node = YANGDynClass(base=yc_node_node_topology__node, is_container='container', yang_name="node",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:node-topology',
                                   defining_module='node-topology', yang_type='container', is_config=True)

    node = __builtin__.property(_get_node, _set_node)

    _pyangbind_elements = OrderedDict([('node', node), ])
